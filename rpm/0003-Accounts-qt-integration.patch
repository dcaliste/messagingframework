From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Valerio Valerio <valerio.valerio@jollamobile.com>
Date: Wed, 29 May 2013 09:44:20 +0300
Subject: [PATCH] Accounts-qt integration.

Squashed commits, either one line description or block comment:

------
Modify .provider/.service to be less generic

Previously, the .provider and .service files used very generic names
and icon values.  Also, the default icon value was specified via a
relative path, which might not exist.  This commit renames both the
provider and service to be less generic, and removes the possibly
invalid icon specification.
-----

- Register SSO accounts that were initially created with disabled email
  service.
- Change email provider/service names.
- Add iconPath property to QMailAccount.

-----
Don't call signon-ui from background process.

Set credentials need update when SSO autenthication fails.
------
Update email.provider icon

Higher quality icon image path is now used by default
-----

- Use service username instead of global if it exists.
- Use password from SSO for CramMd5 authentication.
- Make installation of SSO provider optional.
- Force refresh of SSO tokens when token returned is the same as last
  one that failed.
- Amend last commit and bump version

-----
Add enablers for credentials checking.

Don't try to re-create SSO sessions when accounts are in checking mode.
Don't try to autoconnect to SMTP server during account setup.
-----

- Save/load QMailAccount::CanTransmit from SSO account.

-----
Install SSO provider and service to test package

Test package need SSO provider and service to run tests properly.
Let's install provider and service to test package.

Signed-off-by: Matti Kosola <matti.kosola@jollamobile.com>
-----

- Save/load QMailAccount::appendSignature from SSO account.
- Update email.service template for unit tests.
- Fix build for systems no having accounts-sso support

-----
Fix memory leak in SSOSessionManager::createSsoIdentity

Accounts::AccountService was allocated and never deleted.
-----
Fixed memory leak in SSOSessionManager::createSsoIdentity

The object allocated by Accounts::Manager::account() needs to be deleted
by the caller.
-----

- Removed unnecessary SSOSessionManager::createSsoIdentity call

-----
Fix tst_qmailstore after config defaults change

Either broken (1) since f274471 ([libqmfclient] Modify
.provider/.service to be less generic) which renamed
GenericEmail.service to email.service so it affects the default
QMailAccountConfiguration now, or (2) already since 9d5d7d6 (Accounts-qt
integration).
-----
Add test cases for QMailStore::messagePropertyUpdated and QMailStore::messageStatusUpdated signals.

Fix test cases for systems not using accounts framework.
-----
Update to libaccounts-qt version 1.13

This commit ensures that we use the Accounts::Account::fromId()
function instead of Accounts::Manager::account() function to
retrieve an account instance, to ensure that we can delete
the returned account instance without causing crashes, due
to a change in version 1.7 of libaccounts-qt.
-----
Remove accounts custom fields debug.

This debug line is not useful since these fields can be check from
accounts-sso itself.
-----

Send correct smtp command when auth is not required(SmtpConfiguration::Auth_NONE)

----
Make SMTP AUTH PLAIN more robust.

SMTP authentication using AUTH PLAIN supports two ways to send the information to the server,
seems that some servers don't support anymore auth in two steps:

c: AUTH PLAIN
S: 334
C: <UserName and password encoded in base64>
S: 235 2.7.0 Authentication successful

Auth in one step introduced by this commit, better to reduce communication with the server

c: AUTH PLAIN <UserName and password encoded in base64>
S: 235 2.7.0 Authentication successful

----

Trigger notification if account credentials are incorrect

For accounts that use passwords, if the credentials are incorrect this
change will cause the "CredentialsNeedUpdate = true" property to be set
on the account, triggering signond to show a notification to the user.

This mirrors the behavour of qmf-oauth2-plugin. See
SSOOauth2Plugin::credentialsNeedUpdate() in
base-qmf-oauth2-plugin/oauth2plugin.cpp
---
 common.pri                                    |    6 +
 .../qmfclient/qmailaccountlistmodel.cpp       |   44 +-
 src/libraries/qmfclient/qmailstore_p.cpp      | 1233 ++++++++++++++++-
 src/libraries/qmfclient/qmailstore_p.h        |   41 +-
 src/libraries/qmfclient/qmfclient.pro         |   29 +
 src/libraries/qmfclient/share/email.provider  |   12 +
 src/libraries/qmfclient/share/email.service   |   65 +
 src/libraries/qmfclient/ssoaccountmanager.cpp |   66 +
 src/libraries/qmfclient/ssoaccountmanager.h   |   75 +
 src/libraries/qmfclient/ssoauthplugin.cpp     |  118 ++
 src/libraries/qmfclient/ssoauthplugin.h       |   74 +
 src/libraries/qmfclient/ssosessionmanager.cpp |  392 ++++++
 src/libraries/qmfclient/ssosessionmanager.h   |  115 ++
 .../qmfmessageserver/qmailauthenticator.cpp   |   19 +-
 .../qmfmessageserver/qmailauthenticator.h     |    4 +
 .../qmfmessageserver/qmfmessageserver.pro     |    9 +
 src/libraries/qmfwidgets/qmfwidgets.pro       |    6 +
 src/plugins/messageservices/imap/imap.pro     |    7 +
 .../imap/imapauthenticator.cpp                |   39 +
 .../messageservices/imap/imapauthenticator.h  |    6 +
 .../messageservices/imap/imapclient.cpp       |  296 +++-
 src/plugins/messageservices/imap/imapclient.h |   28 +-
 .../messageservices/imap/imapprotocol.cpp     |   43 +-
 .../messageservices/imap/imapprotocol.h       |    4 +
 .../messageservices/imap/imapservice.cpp      |   66 +
 src/plugins/messageservices/pop/pop.pro       |    7 +
 .../messageservices/pop/popauthenticator.cpp  |   35 +
 .../messageservices/pop/popauthenticator.h    |    5 +
 src/plugins/messageservices/pop/popclient.cpp |  127 ++
 src/plugins/messageservices/pop/popclient.h   |   25 +
 .../messageservices/pop/popservice.cpp        |   25 +
 src/plugins/messageservices/smtp/smtp.pro     |    7 +
 .../smtp/smtpauthenticator.cpp                |   64 +-
 .../messageservices/smtp/smtpauthenticator.h  |    5 +
 .../messageservices/smtp/smtpclient.cpp       |  172 ++-
 src/plugins/messageservices/smtp/smtpclient.h |   28 +
 .../messageservices/smtp/smtpservice.cpp      |    8 +
 src/plugins/plugins.pro                       |    3 +
 src/plugins/ssoauth/password/password.pro     |   21 +
 .../ssoauth/password/passwordplugin.cpp       |  200 +++
 src/plugins/ssoauth/password/passwordplugin.h |   78 ++
 src/tools/messageserver/servicehandler.cpp    |   13 +
 tests/tst_qmailstore/tst_qmailstore.cpp       |   93 +-
 43 files changed, 3645 insertions(+), 68 deletions(-)
 create mode 100644 src/libraries/qmfclient/share/email.provider
 create mode 100644 src/libraries/qmfclient/share/email.service
 create mode 100644 src/libraries/qmfclient/ssoaccountmanager.cpp
 create mode 100644 src/libraries/qmfclient/ssoaccountmanager.h
 create mode 100644 src/libraries/qmfclient/ssoauthplugin.cpp
 create mode 100644 src/libraries/qmfclient/ssoauthplugin.h
 create mode 100644 src/libraries/qmfclient/ssosessionmanager.cpp
 create mode 100644 src/libraries/qmfclient/ssosessionmanager.h
 create mode 100644 src/plugins/ssoauth/password/password.pro
 create mode 100644 src/plugins/ssoauth/password/passwordplugin.cpp
 create mode 100644 src/plugins/ssoauth/password/passwordplugin.h

diff --git a/common.pri b/common.pri
index c690ce66..bfd17e85 100644
--- a/common.pri
+++ b/common.pri
@@ -2,6 +2,12 @@ CONFIG(debug,debug|release) {
     DEFINES += QMF_ENABLE_LOGGING
 }
 
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
 
 win32 | macx {
 
diff --git a/src/libraries/qmfclient/qmailaccountlistmodel.cpp b/src/libraries/qmfclient/qmailaccountlistmodel.cpp
index 28f566cb..63d98c53 100644
--- a/src/libraries/qmfclient/qmailaccountlistmodel.cpp
+++ b/src/libraries/qmfclient/qmailaccountlistmodel.cpp
@@ -341,31 +341,37 @@ void QMailAccountListModel::accountsAdded(const QMailAccountIdList& ids)
     { 
         foreach(const QMailAccountId &id,results)
         {
-            LessThanFunctorA lessThan(d->sortKey);
+            if (!d->idList.contains(id)) {
+                LessThanFunctorA lessThan(d->sortKey);
 
-            //if sorting the list fails, then resort to a complete refresh
-            if(lessThan.invalidatedList())
-                fullRefresh();
-            else
-            {
-                QMailAccountIdList::iterator itr = d->lowerBound(id, lessThan);
-                int newIndex = (itr - d->idList.begin());
+                //if sorting the list fails, then resort to a complete refresh
+                if (lessThan.invalidatedList())
+                    fullRefresh();
+                else
+                {
+                    QMailAccountIdList::iterator itr = d->lowerBound(id, lessThan);
+                    int newIndex = (itr - d->idList.begin());
 
-                beginInsertRows(QModelIndex(),newIndex,newIndex);
-                d->idList.insert(itr, id);
+                    beginInsertRows(QModelIndex(),newIndex,newIndex);
+                    d->idList.insert(itr, id);
+                    endInsertRows();
+                }
+            } else {
+                qWarning() << "QMailAccountListModel: Account with the same id already present in the model";
+            }
+        }
+    } else {
+        foreach (const QMailAccountId &id,results) {
+            if (!d->idList.contains(id)) {
+                int index = d->idList.count();
+                beginInsertRows(QModelIndex(),index,(index + results.count() - 1));
+                d->idList.append(id);
                 endInsertRows();
+            } else {
+                qWarning() << "QMailAccountListModel: Account with the same id already present in the model";
             }
         }
     }
-    else
-    {
-        int index = d->idList.count();
-
-        beginInsertRows(QModelIndex(),index,(index + results.count() - 1));
-        foreach(const QMailAccountId &id,results)
-            d->idList.append(id);
-        endInsertRows();
-    }
     d->needSynchronize = false;
 }
 
diff --git a/src/libraries/qmfclient/qmailstore_p.cpp b/src/libraries/qmfclient/qmailstore_p.cpp
index 52b6a03f..bb94de54 100644
--- a/src/libraries/qmfclient/qmailstore_p.cpp
+++ b/src/libraries/qmfclient/qmailstore_p.cpp
@@ -48,6 +48,10 @@
 #include <QThread>
 #include <QRegularExpression>
 
+#ifdef USE_ACCOUNTS_QT
+#include <QSharedPointer>
+#endif
+
 #if defined(Q_OS_LINUX)
 #include <malloc.h>
 #endif
@@ -1833,7 +1837,15 @@ QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAcc
         bool noCase(caseInsensitiveProperty(a.property));
 
         QString expression = columnExpression(columnName, a.op, a.valueList, patternMatching, bitwise, noCase);
-        
+#ifdef USE_ACCOUNTS_QT
+        Q_UNUSED (store);
+        // Only ID could be queried here,
+        // All other properties will be queried
+        // from Accounts subsystem
+        Q_ASSERT(a.property == QMailAccountKey::Id);
+        q << expression;
+#else
+
         switch(a.property)
         {
         case QMailAccountKey::Id:
@@ -1875,13 +1887,17 @@ QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAcc
             q << expression;
             break;
         }
+#endif
     }
     return item;
 }
 
 template<>
-QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMessageKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
+QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &key, const QMailMessageKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
 {
+#ifndef USE_ACCOUNTS_QT
+    Q_UNUSED(key);
+#endif
     QString item;
     {
         QTextStream q(&item);
@@ -1966,10 +1982,20 @@ QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMes
         case QMailMessageKey::ParentAccountId:
             if(a.valueList.first().canConvert<QMailAccountKey>()) {
                 QMailAccountKey parentAccountKey = a.valueList.first().value<QMailAccountKey>();
+#ifdef USE_ACCOUNTS_QT
+                QMailAccountIdList parentAccountIdList = store.searchSSOAccounts(parentAccountKey);
+
+                // Rewrite argument and execute builder again
+                QMailMessageKey::ArgumentType &arg = const_cast<QMailMessageKey::ArgumentType&>(a);
+                arg = QMailMessageKey::parentAccountId(parentAccountIdList, QMailDataComparator::Includes).arguments().first();
+                return whereClauseItem(key, arg, alias, field, store);
+#else
+
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
                 q << store.buildWhereClause(QMailStorePrivate::Key(parentAccountKey, nestedAlias)) << ")";
+#endif
             } else {
                 q << expression;
             }
@@ -2047,8 +2073,11 @@ QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMes
 }
 
 template<>
-QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolderKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
+QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &key, const QMailFolderKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
 {
+#ifndef USE_ACCOUNTS_QT
+    Q_UNUSED(key);
+#endif
     QString item;
     {
         QTextStream q(&item);
@@ -2113,10 +2142,19 @@ QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolde
         case QMailFolderKey::ParentAccountId:
             if(a.valueList.first().canConvert<QMailAccountKey>()) {
                 QMailAccountKey accountSubKey = a.valueList.first().value<QMailAccountKey>();
+#ifdef USE_ACCOUNTS_QT
+                QMailAccountIdList acountIdList = store.searchSSOAccounts(accountSubKey);
+
+                // Rewrite argument and execute builder again
+                QMailFolderKey::ArgumentType &arg = const_cast<QMailFolderKey::ArgumentType&>(a);
+                arg = QMailFolderKey::parentAccountId(acountIdList, QMailDataComparator::Includes).arguments().first();
+                return whereClauseItem(key, arg, alias, field, store);
+#else
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
                 q << store.buildWhereClause(QMailStorePrivate::Key(accountSubKey, nestedAlias)) << ")";
+#endif
             } else {
                 q << expression;
             }
@@ -2300,6 +2338,442 @@ QMailContentManager::DurabilityRequirement durability(bool commitOnSuccess)
 {
     return (commitOnSuccess ? QMailContentManager::EnsureDurability : QMailContentManager::DeferDurability);
 }
+#ifdef USE_ACCOUNTS_QT
+// Forward declaration
+bool SSOAccountSatisfyTheKey(Accounts::Account* ssoAccount, const QMailAccountKey& key);
+
+template <typename Property>
+bool SSOAccountCompareProperty(Accounts::Account* ssoAccount, Property value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        if (!arguments.front().canConvert<Property>()) {
+            if (arguments.front().canConvert<QMailAccountKey>()) {
+                QMailAccountKey accountKey = arguments.front().value<QMailAccountKey>();
+                return SSOAccountSatisfyTheKey(ssoAccount, accountKey);
+            }
+
+            qMailLog(Messaging) << "Failed to convert argument";
+            return false;
+        }
+
+        Property argument = arguments.front().value<Property>();
+        switch (op) {
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            default:
+                qMailLog(Messaging) << "This comparator is not supported";
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+        switch (op) {
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (argument.canConvert<Property>() && argument.value<Property>() == value)
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (argument.canConvert<Property>() && argument.value<Property>() == value)
+                        return false;
+                }
+                return true;
+
+
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+            default:
+                qMailLog(Messaging) << "This comparator is not supported";
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+
+    Q_ASSERT(false);
+    return false;
+}
+
+template <>
+bool SSOAccountCompareProperty(Accounts::Account*, quint64 value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        bool ok = false;
+        quint64 argument = arguments.front().toULongLong(&ok);
+        if (!ok) {
+            qMailLog(Messaging) << "Failed to convert to quing64";
+            return false;
+        }
+
+        switch (op) {
+            case QMailKey::LessThan:
+                return value < argument;
+
+            case QMailKey::LessThanEqual:
+                return value <= argument;
+
+            case QMailKey::GreaterThan:
+                return value > argument;
+
+            case QMailKey::GreaterThanEqual:
+                return value >= argument;
+
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                return ((value & argument) == argument);
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                return !(value & argument);
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+
+        switch (op) {
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+                // This comparator is not supported for multiple integer arguments
+                Q_ASSERT(false);
+                break;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toULongLong())
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toULongLong())
+                        return false;
+                }
+                return true;
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+    Q_ASSERT(false);
+    return false;
+}
+
+template <>
+bool SSOAccountCompareProperty(Accounts::Account*, const QString& value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        if (!arguments.front().canConvert<QString>()) {
+            qMailLog(Messaging) << "Failed to convert to string";
+            return false;
+        }
+
+        QString argument = arguments.front().toString();
+        switch (op) {
+            case QMailKey::LessThan:
+                return value < argument;
+
+            case QMailKey::LessThanEqual:
+                return value <= argument;
+
+            case QMailKey::GreaterThan:
+                return value > argument;
+
+            case QMailKey::GreaterThanEqual:
+                return value >= argument;
+
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                return value.contains(argument);
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                return !value.contains(argument);
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+
+        switch (op) {
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+                // This comparator is not supported for multiple integer arguments
+                Q_ASSERT(false);
+                break;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toString())
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toString())
+                        return false;
+                }
+                return true;
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+    Q_ASSERT(false);
+    return false;
+}
+
+bool SSOAccountCompareProperty(Accounts::Account* ssoAccount, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count() == 1);
+
+    QStringList argument = arguments.front().toStringList();
+
+    QString key   = argument.front();
+    QString value = argument.count() == 2 ? argument.back() : QString();
+
+    ssoAccount->beginGroup("customFields");
+
+    bool result = false;
+    switch (op) {
+        case QMailKey::LessThan:
+        case QMailKey::LessThanEqual:
+        case QMailKey::GreaterThan:
+        case QMailKey::GreaterThanEqual:
+            // This comparator is not supported for custom fields
+            Q_ASSERT(false);
+            break;
+
+        case QMailKey::Equal:
+            result = ssoAccount->contains(key) && (ssoAccount->valueAsString(key) == value);
+            break;
+
+        case QMailKey::NotEqual:
+            result = !ssoAccount->contains(key) || (ssoAccount->valueAsString(key) != value);
+            break;
+
+        case QMailKey::Includes:
+        case QMailKey::Present:
+            result = ssoAccount->contains(key) &&  ssoAccount->valueAsString(key).contains(value);
+            break;
+
+        case QMailKey::Excludes:
+        case QMailKey::Absent:
+            result = !(ssoAccount->contains(key) && ssoAccount->valueAsString(key).contains(value));
+            break;
+
+        default:
+            Q_ASSERT(false);
+            break;
+    }
+    ssoAccount->endGroup();
+    return result;
+}
+
+bool SSOAccountSatisfyTheProperty(Accounts::Account* ssoAccount, const QMailAccountKey::ArgumentType& argument)
+{
+    Q_ASSERT(ssoAccount);
+
+    switch (argument.property) {
+        case QMailAccountKey::Id:
+            return SSOAccountCompareProperty<QMailAccountId>(ssoAccount, QMailAccountId(ssoAccount->id()), argument.op, argument.valueList);
+
+        case QMailAccountKey::Name:
+            return SSOAccountCompareProperty<const QString&>(ssoAccount, ssoAccount->displayName(), argument.op, argument.valueList);
+
+        case QMailAccountKey::MessageType:
+            return SSOAccountCompareProperty<quint64>(ssoAccount, ssoAccount->valueAsInt("type"), argument.op, argument.valueList);
+
+        case QMailAccountKey::FromAddress:
+            return SSOAccountCompareProperty<const QString&>(ssoAccount, QMailAddress(ssoAccount->valueAsString("emailaddress")).address(), argument.op, argument.valueList);
+
+        case QMailAccountKey::Status: {
+            Accounts::Service service = ssoAccount->selectedService();
+
+            ssoAccount->selectService();
+            const bool& enabled = ssoAccount->enabled();
+            ssoAccount->selectService(service);
+
+            quint64 status = ssoAccount->valueAsUInt64("status");
+            status &= (~QMailAccount::Enabled);
+            status |= enabled?(QMailAccount::Enabled):0;
+
+            bool canTransmit = ssoAccount->valueAsBool("canTransmit", true);
+            status &= (~QMailAccount::CanTransmit);
+            status |= canTransmit?(QMailAccount::CanTransmit):0;
+
+            bool appendSignature = ssoAccount->valueAsBool("signatureEnabled", true);
+            status &= (~QMailAccount::AppendSignature);
+            status |= appendSignature?(QMailAccount::AppendSignature):0;
+
+            return SSOAccountCompareProperty<quint64>(ssoAccount,
+                                                      status,
+                                                      argument.op, argument.valueList);
+        }
+
+        case QMailAccountKey::Custom:
+            return SSOAccountCompareProperty(ssoAccount, argument.op, argument.valueList);
+
+        default:
+            Q_ASSERT(false);
+            break;
+    }
+    return false;
+}
+
+bool SSOAccountSatisfyTheKey(Accounts::Account* ssoAccount, const QMailAccountKey& key)
+{
+    Q_ASSERT(ssoAccount);
+
+    if (key.isNonMatching())
+        return false;
+
+    if (key.isEmpty())
+        return true;
+
+    // In case of it is not compound key and has got a list of arguments
+    // follow the list of arguments and compare
+    if (!key.arguments().isEmpty()) {
+        typedef QmfList<QMailAccountKey::ArgumentType> ListOfArguments;
+        ListOfArguments::const_iterator it = key.arguments().begin();
+
+        bool result = SSOAccountSatisfyTheProperty(ssoAccount, *it);
+        while (++it != key.arguments().end()) {
+            switch (key.combiner()) {
+                case QMailKey::And:
+                    result = result && SSOAccountSatisfyTheProperty(ssoAccount, *it);
+                    break;
+                case QMailKey::Or:
+                    result = result || SSOAccountSatisfyTheProperty(ssoAccount, *it);
+                    break;
+                default:
+                    Q_ASSERT(false);
+                    break;
+            }
+        }
+
+        // Return negated value if key was negeated
+        return key.isNegated() ? !result : result;
+    }
+
+    // In case of compound key, process each subkey separatelly
+    if (!key.subKeys().isEmpty()) {
+        typedef QmfList<QMailAccountKey> ListOfKeys;
+        ListOfKeys::const_iterator it = key.subKeys().begin();
+
+        bool result = SSOAccountSatisfyTheKey(ssoAccount, *it);
+        while (++it != key.subKeys().end()) {
+            switch (key.combiner()) {
+                case QMailKey::And:
+                    result = result && SSOAccountSatisfyTheKey(ssoAccount, *it);
+                    break;
+                case QMailKey::Or:
+                    result = result || SSOAccountSatisfyTheKey(ssoAccount, *it);
+                    break;
+                default:
+                    Q_ASSERT(false);
+                    break;
+            }
+        }
+
+        // Return negated value if key was negeated
+        return key.isNegated() ? !result : result;
+    }
+
+    // This key is not empty and has neither subkeys nor arguments.
+    Q_ASSERT(false);
+    return false;
+}
+
+void SSOHandleError(const Accounts::Error& error)
+{
+    switch (error.type()) {
+    case Accounts::Error::NoError:
+        break;
+    case Accounts::Error::Deleted:
+    case Accounts::Error::AccountNotFound:
+        qWarning() << "Accounts:" << error.message();
+        break;
+    case Accounts::Error::Unknown:
+    case Accounts::Error::Database:
+    case Accounts::Error::DatabaseLocked:
+        qCritical() << "Accounts:" << error.message();
+        Q_ASSERT (false);
+        break;
+    default:
+        Q_ASSERT (false);
+    }
+}
+#endif
 
 } // namespace
 
@@ -2535,7 +3009,35 @@ QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
         contentMutex = new ProcessMutex(databaseIdentifier(), 3);
     }
     connect(&databaseUnloadTimer, SIGNAL(timeout()), this, SLOT(unloadDatabase()));
+#ifdef USE_ACCOUNTS_QT
+    // manager to notify QMailStore about the changes
+    connect(manager, SIGNAL(accountCreated(Accounts::AccountId)), this, SLOT(accountCreated(Accounts::AccountId)));
+    connect(manager, SIGNAL(accountRemoved(Accounts::AccountId)), this, SLOT(accountRemoved(Accounts::AccountId)));
+    connect(manager, SIGNAL(accountUpdated(Accounts::AccountId)), this, SLOT(accountUpdated(Accounts::AccountId)));
+#endif
+}
+
+#ifdef USE_ACCOUNTS_QT
+QSharedPointer<Accounts::Account> QMailStorePrivate::getEmailAccount(const Accounts::AccountId id)
+{
+    //get account from the manager
+    QSharedPointer<Accounts::Account> ssoAccount(Accounts::Account::fromId(manager, id, this));
+
+    if (!ssoAccount) {
+        qWarning() << Q_FUNC_INFO << "Account with was not found" ;
+        SSOHandleError(manager->lastError());
+        return ssoAccount;
+    }
+
+    // check if it is an e-mail account
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    if (!services.count()) {
+        ssoAccount = QSharedPointer<Accounts::Account>();
+    }
+
+    return ssoAccount;
 }
+#endif
 
 QMailStorePrivate::~QMailStorePrivate()
 {
@@ -2812,6 +3314,25 @@ void QMailStorePrivate::clearContent()
 
     Transaction t(this);
 
+#ifdef USE_ACCOUNTS_QT
+    // Remove all SSO email accounts
+    Accounts::AccountIdList accountIDList = manager->accountList("e-mail");
+
+    // Populate all E-Mail accounts
+    foreach (Accounts::AccountId accountID, accountIDList) {
+        // Remove account
+        QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(accountID);
+
+        if (ssoAccount) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+        } else {
+            qWarning() << Q_FUNC_INFO << "E-mail Services not found, make sure that *.service and *.provider files are properly installed and e-mail services are enabled.";
+            SSOHandleError(manager->lastError());
+        }
+    }
+#endif
+
     // Drop all data
     foreach (const QString &table, database()->tables()) {
         if (table != QLatin1String("versioninfo") && table != QLatin1String("mailstatusflags")) {
@@ -3136,10 +3657,18 @@ bool QMailStorePrivate::idValueExists(quint64 id, const QString& table)
     return (query.first());
 }
 
+#ifdef USE_ACCOUNTS_QT
+bool QMailStorePrivate::idExists(const QMailAccountId& id)
+{
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    return (ssoAccount != NULL);
+}
+#else
 bool QMailStorePrivate::idExists(const QMailAccountId& id, const QString& table)
 {
     return idValueExists(id.toULongLong(), (table.isEmpty() ? QLatin1String("mailaccounts") : table));
 }
+#endif
 
 bool QMailStorePrivate::idExists(const QMailFolderId& id, const QString& table)
 {
@@ -3168,6 +3697,51 @@ bool QMailStorePrivate::messageExists(const QString &serveruid, const QMailAccou
     return query.first();
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailAccount QMailStorePrivate::extractAccount(const QSharedPointer<Accounts::Account>& ssoAccount)
+{
+    Q_ASSERT(ssoAccount);
+
+    QMailAccount result;
+    result.setId(QMailAccountId(ssoAccount->id()));
+    QString name = ssoAccount->valueAsString("email/email_box_name");
+    if (name.isEmpty())
+        name = ssoAccount->displayName();
+    result.setName(name);
+    result.setMessageType(static_cast<QMailMessageMetaDataFwd::MessageType>(ssoAccount->valueAsInt("type")));
+    result.setStatus(ssoAccount->valueAsUInt64("status"));
+
+    Accounts::Service service = ssoAccount->selectedService();
+
+    ssoAccount->selectService();
+    const bool& enabled = ssoAccount->enabled();
+    ssoAccount->selectService(service);
+    const bool& isDefault = ssoAccount->valueAsBool("email/default");
+    const bool& canTransmit = ssoAccount->valueAsBool("canTransmit", true);
+    const bool& appendSignature = ssoAccount->valueAsBool("signatureEnabled", true);
+
+    result.setStatus(QMailAccount::Enabled, enabled);
+    result.setStatus(QMailAccount::PreferredSender, isDefault);
+    result.setStatus(QMailAccount::CanTransmit, canTransmit);
+    result.setStatus(QMailAccount::AppendSignature, appendSignature);
+
+    result.setSignature(ssoAccount->valueAsString("signature"));
+    result.setFromAddress(ssoAccount->contains("fullName")?
+                          QMailAddress(ssoAccount->valueAsString("fullName"),ssoAccount->valueAsString("emailaddress")):
+                          QMailAddress(ssoAccount->valueAsString("emailaddress")));
+
+    if ((static_cast<uint>(ssoAccount->valueAsUInt64("lastSynchronized"))) == 0) {
+            result.setLastSynchronized(QMailTimeStamp());
+    }
+    else {
+        result.setLastSynchronized(QMailTimeStamp(QDateTime::fromTime_t(static_cast<uint>(ssoAccount->valueAsUInt64("lastSynchronized")))));
+    }
+
+    result.setIconPath(ssoAccount->valueAsString("iconPath"));
+
+    return result;
+}
+#else
 QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
 {
     const AccountRecord record(r);
@@ -3185,7 +3759,7 @@ QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
 
     return result;
 }
-
+#endif
 
 QMailThread QMailStorePrivate::extractThread(const QSqlRecord& r)
 {
@@ -3428,8 +4002,12 @@ QString QMailStorePrivate::buildOrderClause(const Key& key) const
         const QMailThreadSortKey &sortKey(key.key<QMailThreadSortKey>());
         return ::buildOrderClause(sortKey.arguments(), key.alias());
     } else if (key.isType<QMailAccountSortKey>()) {
+#ifdef USE_ACCOUNTS_QT
+        Q_ASSERT(false);
+#else
         const QMailAccountSortKey &sortKey(key.key<QMailAccountSortKey>());
         return ::buildOrderClause(sortKey.arguments(), key.alias());
+#endif
     } 
 
     return QString();
@@ -5499,21 +6077,250 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::updateCustomFields(quint64 i
     return Success;
 }
 
-QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::addAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString>& fields)
 {
-    QString sql(QLatin1String("SELECT name,value FROM %1 WHERE id=?"));
-    QSqlQuery query(simpleQuery(sql.arg(tableName),
-                                QVariantList() << id,
-                                QString::fromLatin1("%1 custom field query").arg(tableName)));
-    if (query.lastError().type() != QSqlError::NoError)
-        return DatabaseFailure;
-
-    while (query.next())
-        fields->insert(query.value(0).toString(), query.value(1).toString());
+    if (!fields.isEmpty()) {
+        ssoAccount->beginGroup("customFields");
 
-    return Success;
-}
+        // Insert any custom fields belonging to this account
+        QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+        for ( ; it != end; ++it) {
+            ssoAccount->setValue(it.key(), QVariant(it.value()));
+        }
+        ssoAccount->endGroup();
 
+        if (!ssoAccount->syncAndBlock())
+            return DatabaseFailure;
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::updateAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields)
+{
+    ssoAccount->beginGroup("customFields");
+
+    QMap<QString, QString> existing;
+    {
+        foreach (const QString& name, ssoAccount->allKeys()) {
+             existing.insert(name, ssoAccount->valueAsString(name));
+        }
+    }
+
+    QVariantList obsoleteFields;
+    QVariantList modifiedFields;
+    QVariantList modifiedValues;
+    QVariantList addedFields;
+    QVariantList addedValues;
+
+    // Compare the sets
+    QMap<QString, QString>::const_iterator fend = fields.end(), eend = existing.end();
+    QMap<QString, QString>::const_iterator it = existing.begin();
+    for ( ; it != eend; ++it) {
+        QMap<QString, QString>::const_iterator current = fields.find(it.key());
+        if (current == fend) {
+            obsoleteFields.append(QVariant(it.key()));
+        } else if (*current != *it) {
+            modifiedFields.append(QVariant(current.key()));
+            modifiedValues.append(QVariant(current.value()));
+        }
+    }
+
+    for (it = fields.begin(); it != fend; ++it) {
+        if (existing.find(it.key()) == eend) {
+            addedFields.append(QVariant(it.key()));
+            addedValues.append(QVariant(it.value()));
+        }
+    }
+
+    if (!obsoleteFields.isEmpty()) {
+        // Remove the obsolete fields
+        foreach (const QVariant& obsolet, obsoleteFields) {
+            ssoAccount->remove(obsolet.toString());
+        }
+    }
+
+    if (!modifiedFields.isEmpty()) {
+        // Batch update of the modified fields
+        QVariantList::const_iterator field = modifiedFields.begin();
+        QVariantList::const_iterator value = modifiedValues.begin();
+        while (field != modifiedFields.end() && value != modifiedValues.end())
+            ssoAccount->setValue(field++->toString(), *value++);
+    }
+
+    if (!addedFields.isEmpty()) {
+        // Batch insert of the added fields
+        QVariantList::const_iterator field = addedFields.begin();
+        QVariantList::const_iterator value = addedValues.begin();
+        while (field != addedFields.end() && value != addedValues.end())
+            ssoAccount->setValue(field++->toString(), *value++);
+
+    }
+
+    ssoAccount->endGroup();
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::accountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, QMap<QString, QString>* fields)
+{
+    ssoAccount->beginGroup("customFields");
+    foreach (const QString& key, ssoAccount->allKeys()) {
+        fields->insert(key, ssoAccount->valueAsString(key));
+    }
+    ssoAccount->endGroup();
+
+    return Success;
+}
+#endif
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
+{
+    QString sql(QLatin1String("SELECT name,value FROM %1 WHERE id=?"));
+    QSqlQuery query(simpleQuery(sql.arg(tableName),
+                                QVariantList() << id,
+                                QString::fromLatin1("%1 custom field query").arg(tableName)));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        fields->insert(query.value(0).toString(), query.value(1).toString());
+
+    return Success;
+}
+
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                                                                      QMailAccountIdList *addedAccountIds,
+                                                                      Transaction &t, bool commitOnSuccess)
+{
+    if (account->id().isValid() && idExists(account->id())) {
+        qWarning() << "Account already exists in database, use update instead";
+        return Failure;
+    }
+
+    // Create new account in Accounts subsystem
+    QSharedPointer<Accounts::Account> ssoAccount(manager->createAccount("email"));
+    if (!ssoAccount) {
+        SSOHandleError(manager->lastError());
+        qMailLog(Messaging) << "Failed to create account";
+        return DatabaseFailure;
+    }
+
+    ssoAccount->setDisplayName(account->name());
+    ssoAccount->setEnabled(account->status() & QMailAccount::Enabled);
+
+    Accounts::ServiceList services = ssoAccount->services("e-mail");
+    if (!services.count()) {
+        qMailLog(Messaging) << "E-mail Services not found, make sure that *.service and *.provider files are properly installed.";
+        return DatabaseFailure;
+    }
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+    Q_ASSERT(service.serviceType() == "e-mail");
+
+    ssoAccount->selectService(service);
+    ssoAccount->setEnabled(true); // service is enabled anyway
+    ssoAccount->setValue("type", static_cast<int>(account->messageType()));
+    ssoAccount->setValue("status", account->status());
+    const bool appendSignature = (account->status() & QMailAccount::AppendSignature);
+    ssoAccount->setValue("signatureEnabled", appendSignature);
+    ssoAccount->setValue("signature", account->signature());
+    ssoAccount->setValue("emailaddress", account->fromAddress().address());
+    ssoAccount->setValue("fullName", account->fromAddress().name());
+    //Account was never synced
+    ssoAccount->setValue("lastSynchronized", quint64(0));
+    ssoAccount->setValue("iconPath", account->iconPath());
+    const bool canTransmit = (account->status() & QMailAccount::CanTransmit);
+    ssoAccount->setValue("canTransmit", canTransmit);
+
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+
+    //Extract the insert id
+    QMailAccountId insertId = QMailAccountId(ssoAccount->id());
+
+    {
+        // Insert any standard folders configured for this account
+        const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
+        if (!folders.isEmpty()) {
+            QVariantList types;
+            QVariantList folderIds;
+
+            QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator it = folders.begin(), end = folders.end();
+            for ( ; it != end; ++it) {
+                types.append(static_cast<int>(it.key()));
+                folderIds.append(it.value().toULongLong());
+            }
+
+            // Batch insert the folders
+            QString sql("INSERT into mailaccountfolders (id,foldertype,folderid) VALUES (%1,?,?)");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(insertId.toULongLong())),
+                                       QVariantList() << QVariant(types)
+                                       << QVariant(folderIds),
+                                       "addAccount mailaccountfolders query"));
+            if (query.lastError().type() != QSqlError::NoError) {
+                ssoAccount->remove();
+                ssoAccount->syncAndBlock();
+                return DatabaseFailure;
+            }
+        }
+
+        // Insert any custom fields belonging to this account
+        AttemptResult result = addAccountCustomFields(ssoAccount, account->customFields());
+        if (result != Success) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+            return result;
+        }
+    }
+
+    if (config) {
+        foreach (const QString &service, config->services()) {
+            QMailAccountConfiguration::ServiceConfiguration &serviceConfig(config->serviceConfiguration(service));
+            const QMap<QString, QString> &fields = serviceConfig.values();
+            QString serviceName = serviceConfig.service();
+
+            // Open configuration group
+            ssoAccount->beginGroup(serviceName);
+
+            // Insert any configuration fields belonging to this account
+            QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+            for ( ; it != end; ++it) {
+                ssoAccount->setValue(it.key(), QVariant(it.value()));
+            }
+            // Close group of keys
+            ssoAccount->endGroup();
+        }
+
+        // Save all changes
+        if (!ssoAccount->syncAndBlock()) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+            return DatabaseFailure;
+        }
+
+        config->setId(insertId);
+    }
+
+    account->setId(insertId);
+
+    if (commitOnSuccess && !t.commit()) {
+        qWarning() << "Could not commit account changes to database";
+
+        account->setId(QMailAccountId()); //revert the id
+        ssoAccount->remove();
+        ssoAccount->syncAndBlock();
+        return DatabaseFailure;
+    }
+
+    addedAccountIds->append(insertId);
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
                                                                       QMailAccountIdList *addedAccountIds, 
                                                                       Transaction &t, bool commitOnSuccess)
@@ -5615,6 +6422,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccou
     addedAccountIds->append(insertId);
     return Success;
 }
+#endif
 
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddFolder(QMailFolder *folder, 
                                                                      QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
@@ -6188,7 +6996,55 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
     if (!id.isValid())
         return Failure;
 
+#ifdef USE_ACCOUNTS_QT
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    if (!ssoAccount)
+      return Failure;
+
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.isValid());
+    Q_ASSERT(service.serviceType() == "e-mail");
+#endif
+
     if (account) {
+#ifdef USE_ACCOUNTS_QT
+        ssoAccount->selectService(service);
+        bool isEmailBoxName = false;
+        if(!ssoAccount->valueAsString("email/email_box_name").isEmpty()) {
+            isEmailBoxName = true;
+            ssoAccount->setValue("email/email_box_name",account->name());
+        }
+        ssoAccount->selectService();
+        if (isEmailBoxName) {
+            ssoAccount->setDisplayName(ssoAccount->valueAsString("username"));
+        }
+        else {
+            ssoAccount->setDisplayName(account->name());
+        }
+        ssoAccount->setEnabled(account->status() & QMailAccount::Enabled);
+        ssoAccount->selectService(service);
+        ssoAccount->setValue("type", static_cast<int>(account->messageType()));
+        ssoAccount->setValue("status", account->status());
+        bool signatureEnabled = account->status() & QMailAccount::AppendSignature;
+        ssoAccount->setValue("signatureEnabled", signatureEnabled);
+        ssoAccount->setValue("signature", account->signature());
+        ssoAccount->setValue("emailaddress", account->fromAddress().address());
+        ssoAccount->setValue("fullName", account->fromAddress().name());
+        if (account->lastSynchronized().isValid()) {
+            ssoAccount->setValue("lastSynchronized", static_cast<quint64>(account->lastSynchronized().toLocalTime().toTime_t()));
+        }
+        else {
+            ssoAccount->setValue("lastSynchronized", quint64(0));
+        }
+        bool isDefault = account->status() & QMailAccount::PreferredSender;
+        bool canTransmit = account->status() & QMailAccount::CanTransmit;
+        ssoAccount->setValue("email/default", isDefault);
+        ssoAccount->setValue("canTransmit", canTransmit);
+        ssoAccount->setValue("iconPath", account->iconPath());
+#else
         QString properties(QLatin1String("type=?, name=?, emailaddress=?, status=?, signature=?, lastsynchronized=?, iconpath=?"));
         QVariantList propertyValues;
         propertyValues << static_cast<int>(account->messageType()) 
@@ -6206,7 +7062,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             if (query.lastError().type() != QSqlError::NoError)
                 return DatabaseFailure;
         }
-
+#endif
         // Update any standard folders configured
         const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
         QMap<QMailFolder::StandardFolder, QMailFolderId> existingFolders;
@@ -6281,13 +7137,20 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         }
 
         if (account->customFieldsModified()) {
+#ifdef USE_ACCOUNTS_QT
+            AttemptResult result = updateAccountCustomFields(ssoAccount, account->customFields());
+#else
             AttemptResult result = updateCustomFields(id.toULongLong(), account->customFields(), QLatin1String("mailaccountcustom"));
+#endif
             if (result != Success)
                 return result;
         }
     }
 
     if (config) {
+#ifdef USE_ACCOUNTS_QT
+        ssoAccount->selectService(service);
+#endif
         // Find the complete set of configuration fields
         QMap<QPair<QString, QString>, QString> fields;
 
@@ -6305,6 +7168,17 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         QMap<QPair<QString, QString>, QString> existing;
 
         {
+#ifdef USE_ACCOUNTS_QT
+            foreach (const QString& group, ssoAccount->childGroups()) {
+                if (group != "customFields") {
+                    ssoAccount->beginGroup(group);
+                    foreach (const QString& name, ssoAccount->allKeys()) {
+                         existing.insert(qMakePair(group, name), ssoAccount->valueAsString(name));
+                    }
+                    ssoAccount->endGroup();
+                }
+            }
+#else
             QSqlQuery query(simpleQuery(QLatin1String("SELECT service,name,value FROM mailaccountconfig WHERE id=?"),
                                         QVariantList() << id.toULongLong(),
                                         QLatin1String("updateAccount mailaccountconfig select query")));
@@ -6313,6 +7187,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
 
             while (query.next())
                 existing.insert(qMakePair(query.value(0).toString(), query.value(1).toString()), query.value(2).toString());
+#endif
         }
 
         QMap<QString, QVariantList> obsoleteFields;
@@ -6349,13 +7224,20 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             for ( ; it != end; ++it) {
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                ssoAccount->beginGroup(service);
+                foreach (const QVariant& field, fields) {
+                    ssoAccount->remove(field.toString());
+                }
+                ssoAccount->endGroup();
+#else
                 QString sql(QLatin1String("DELETE FROM mailaccountconfig WHERE id=? AND service='%1' AND name IN %2"));
                 QSqlQuery query(simpleQuery(sql.arg(service).arg(expandValueList(fields)),
                                             QVariantList() << id.toULongLong() << fields,
                                             QLatin1String("updateAccount mailaccountconfig delete query")));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
 
@@ -6366,13 +7248,23 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
                 const QVariantList &values = vit.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                QVariantList::const_iterator field = fields.begin();
+                QVariantList::const_iterator value = values.begin();
+
+                ssoAccount->beginGroup(service);
+                while (field != fields.end() && value != values.end())
+                    ssoAccount->setValue(field++->toString(), *value++);
+
+                ssoAccount->endGroup();
+#else
                 QString sql(QLatin1String("UPDATE mailaccountconfig SET value=? WHERE id=%1 AND service='%2' AND name=?"));
                 QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
                                            QVariantList() << QVariant(values) << QVariant(fields),
                                            QLatin1String("updateAccount mailaccountconfig update query")));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
 
@@ -6384,12 +7276,23 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 const QVariantList &fields = it.value();
                 const QVariantList &values = vit.value();
                 
+#ifdef USE_ACCOUNTS_QT
+                QVariantList::const_iterator field = fields.begin();
+                QVariantList::const_iterator value = values.begin();
+
+                ssoAccount->beginGroup(service);
+                while (field != fields.end() && value != values.end())
+                    ssoAccount->setValue(field++->toString(), *value++);
+
+                ssoAccount->endGroup();
+#else
                 QString sql(QLatin1String("INSERT INTO mailaccountconfig (id,service,name,value) VALUES (%1,'%2',?,?)"));
                 QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
                                            QVariantList() << QVariant(fields) << QVariant(values),
                                            QLatin1String("updateAccount mailaccountconfig insert query")));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
     }
@@ -6398,7 +7301,12 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         qWarning() << "Could not commit account update to database";
         return DatabaseFailure;
     }
-        
+
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+#endif
+
     if (account) {
         // Update the account cache
         if (accountCache.contains(id))
@@ -7441,6 +8349,10 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptEnsureDurability(Tran
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const QMailAccountKey &key, int *result, 
                                                                          ReadLock &)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList accountIDList = searchSSOAccounts(key);
+    *result =  accountIDList.count();
+#else
     QSqlQuery query(simpleQuery(QLatin1String("SELECT COUNT(*) FROM mailaccounts"),
                                 Key(key),
                                 QLatin1String("countAccounts mailaccounts query")));
@@ -7449,7 +8361,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const Q
 
     if (query.first())
         *result = extractValue<int>(query.value(0));
-
+#endif
     return Success;
 }
 
@@ -7520,6 +8432,14 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const Q
                                                                          QMailAccountIdList *ids, 
                                                                          ReadLock &)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList accountIDList = searchSSOAccounts(key, sortKey);
+
+    if (limit)
+        *ids << accountIDList.mid(offset, limit);
+    else
+        *ids << accountIDList.mid(offset, -1);
+#else
     QSqlQuery query(simpleQuery(QLatin1String("SELECT id FROM mailaccounts"),
                                 QVariantList(),
                                 QList<Key>() << Key(key) << Key(sortKey),
@@ -7530,7 +8450,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const Q
 
     while (query.next())
         ids->append(QMailAccountId(extractValue<quint64>(query.value(0))));
-
+#endif
     return Success;
 }
 
@@ -7594,6 +8514,75 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryMessages(const Q
     return Success;
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id,
+                                                                   QMailAccount *result,
+                                                                   ReadLock &)
+{
+    if (!id.isValid())
+        return Success;
+
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    if (!ssoAccount) {
+        // On the contrary to updateAccount, not finding an account is not a failure
+        // here, because the purpose of this function is to inquire for one.
+        // We return success and we keep result as invalid / empty.
+        result->setId(QMailAccountId());
+        return Success;
+    }
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.serviceType() == "e-mail");
+
+    ssoAccount->selectService(service);
+
+    *result = extractAccount(ssoAccount);
+    Q_ASSERT(result->id() == id);
+
+    {
+        // Find any standard folders configured for this account
+        QSqlQuery query(simpleQuery("SELECT foldertype,folderid FROM mailaccountfolders WHERE id=?",
+                                    QVariantList() << id.toULongLong(),
+                                    "account mailaccountfolders query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next())
+            result->setStandardFolder(QMailFolder::StandardFolder(query.value(0).toInt()), QMailFolderId(query.value(1).toULongLong()));
+    }
+
+    // Find any custom fields for this SSO account
+    QMap<QString, QString> fields;
+    AttemptResult attemptResult = accountCustomFields(ssoAccount, &fields);
+    if (attemptResult != Success)
+        return attemptResult;
+
+    result->setCustomFields(fields);
+    result->setCustomFieldsModified(false);
+
+    // Find the type of the account
+    foreach (const QString& group, ssoAccount->childGroups()) {
+        if (group != "customFields") {
+            ssoAccount->beginGroup(group);
+
+            QString serviceType = ssoAccount->valueAsString("servicetype");
+            if (serviceType.contains("source"))
+                result->addMessageSource(group);
+
+            if (serviceType.contains("sink"))
+                result->addMessageSink(group);
+
+            ssoAccount->endGroup();
+        }
+    }
+
+    //update cache
+    accountCache.insert(*result);
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id, 
                                                                    QMailAccount *result, 
                                                                    ReadLock &)
@@ -7607,6 +8596,12 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAc
 
         if (query.first()) {
             *result = extractAccount(query.record());
+        } else {
+            // On the contrary to updateAccount, not finding an account is not a failure
+            // here, because the purpose of this function is to inquire for one.
+            // We return success and we keep result as invalid / empty.
+            result->setId(QMailAccountId());
+            return Success;
         }
     }
 
@@ -7660,7 +8655,50 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAc
 
     return Failure;
 }
+#endif
+
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id,
+                                                                                QMailAccountConfiguration *result,
+                                                                                ReadLock &)
+{
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+
+    if (!ssoAccount)
+        return Failure;
+
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+
+    Accounts::Service service = services.first();
 
+    Q_ASSERT(service.serviceType() == "e-mail");
+    ssoAccount->selectService(service);
+
+    foreach (const QString& group, ssoAccount->childGroups()) {
+        if (group != "customFields") {
+            if (!result->services().contains(group)) {
+                // Add this service to the configuration
+                result->addServiceConfiguration(group);
+            }
+
+            QMailAccountConfiguration::ServiceConfiguration* serviceConfig = &result->serviceConfiguration(group);
+            Q_ASSERT(serviceConfig);
+
+            ssoAccount->beginGroup(group);
+            foreach (const QString& key, ssoAccount->allKeys()) {
+                serviceConfig->setValue(key,ssoAccount->valueAsString(key));
+            }
+            ssoAccount->endGroup();
+        }
+    }
+
+    result->setId(id);
+    result->setModified(false);
+
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id, 
                                                                                 QMailAccountConfiguration *result, 
                                                                                 ReadLock &)
@@ -7710,6 +8748,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(
 
     return Success;
 }
+#endif
 
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptThread(const QMailThreadId &id, QMailThread *result, ReadLock &)
 {
@@ -8828,11 +9867,27 @@ bool QMailStorePrivate::checkPreconditions(const QMailFolder& folder, bool updat
 
     if(folder.parentAccountId().isValid())
     {
+#ifdef USE_ACCOUNTS_QT
+
+        Accounts::AccountId accountId = folder.parentAccountId().toULongLong();
+        QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(accountId);
+
+        if (!ssoAccount) {
+          qWarning() << "Parent account does not exist!";
+          return false;
+        }
+
+        if (!ssoAccount->supportsService("e-mail")) {
+          qMailLog(Messaging) << "Parent account does not support e-mail service!";
+          return false;
+        }
+#else
         if (!idExists(folder.parentAccountId(), QLatin1String("mailaccounts")))
         {
             qWarning() << "Parent account does not exist!";
             return false;
         }
+#endif
     }
 
     return true;
@@ -9355,6 +10410,14 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
                                        QMailThreadIdList& modifiedThreadIds,
                                        QMailAccountIdList& modifiedAccountIds)
 {
+#ifdef USE_ACCOUNTS_QT
+    // Searching across all accounts inside SSO
+    deletedAccountIds << searchSSOAccounts(key);
+
+    // No accounts? Then we're already done
+    if (deletedAccountIds.isEmpty())
+        return true;
+#else
     {
         // Get the identifiers for all the accounts we're deleting
         QSqlQuery query(simpleQuery(QLatin1String("SELECT t0.id FROM mailaccounts t0"),
@@ -9374,6 +10437,7 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         if (noAccounts)
             return true;
     }
+#endif
 
     // We won't create new message removal records, since there will be no account to link them to
     QMailStore::MessageRemovalOption option(QMailStore::NoRemovalRecord);
@@ -9418,7 +10482,24 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         // Delete all threads contained by the account we're deleting
         if (!deleteThreads(threadKey, option, deletedThreadIds, deletedMessageIds, expiredContent, updatedMessageIds, modifiedFolderIds, modifiedThreadIds, modifiedAccountIds))
             return false;
+#ifdef USE_ACCOUNTS_QT
+    {
+        // Remove accounts from SSO
+        foreach (const QMailAccountId& accountID, deletedAccountIds) {
+
+            QSharedPointer<Accounts::Account> ssoAccount(Accounts::Account::fromId(manager, accountID.toULongLong(), this));
 
+            if (ssoAccount) {
+                ssoAccount->remove();
+                if (!ssoAccount->syncAndBlock()) {
+                    return false;
+                }
+            } else {
+                SSOHandleError(manager->lastError());
+            }
+        }
+    }
+#else
     {
         // Remove any custom fields associated with these accounts
         QSqlQuery query(simpleQuery(QLatin1String("DELETE FROM mailaccountcustom"),
@@ -9445,7 +10526,7 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         if (query.lastError().type() != QSqlError::NoError)
             return false;
     }
-
+#endif
     // Do not report any deleted entities as updated
     for (QMailMessageIdList::iterator mit = updatedMessageIds.begin(); mit != updatedMessageIds.end(); ) {
         if (deletedMessageIds.contains(*mit)) {
@@ -9819,3 +10900,109 @@ void QMailStorePrivate::reconnectIpc()
         ipcLastDbUpdated = lastDbUpdated;
     }
 }
+
+#ifdef USE_ACCOUNTS_QT
+QMailAccountIdList QMailStorePrivate::searchSSOAccounts(const QMailAccountKey& key, const QMailAccountSortKey& sortKey) const
+{
+    Q_UNUSED (sortKey);
+
+    Accounts::AccountIdList accountIDList = manager->accountList("e-mail");
+
+    // Populate all E-Mail accounts
+    typedef QList<Accounts::Account*> AccountList;
+    QMailAccountIdList accountList;
+
+    foreach (const Accounts::AccountId& accountID, accountIDList) {
+        Accounts::Account* ssoAccount = Accounts::Account::fromId(manager, accountID, const_cast<QMailStorePrivate*>(this));
+        if (!ssoAccount) {
+            SSOHandleError(manager->lastError());
+            continue;
+        }
+
+        Accounts::ServiceList services = ssoAccount->enabledServices();
+        const int &count = services.count();
+        switch (count) {
+        case 0: // ignore such accounts
+            break;
+        case 1: {
+            Accounts::Service service = services.first();
+            ssoAccount->selectService(service);
+            if (SSOAccountSatisfyTheKey(ssoAccount, key))
+                accountList.append(QMailAccountId(ssoAccount->id()));
+            } break;
+        default:
+            qCritical() << Q_FUNC_INFO << "Account must contain one enabled email service. Got" << count
+                        << "for account" << accountID;
+            Q_ASSERT (false);
+            return QMailAccountIdList();
+        }
+
+        delete ssoAccount;
+    }
+
+    /*
+     * TBD: Use sortKey to sort found accounts properly
+     */
+
+    return accountList;
+}
+
+void QMailStorePrivate::accountCreated(Accounts::AccountId id)
+{
+    // ignore non-email accounts
+    if (!accountValid(id))
+        return;
+
+    QMailAccountIdList ids;
+    ids << QMailAccountId(id);
+    Q_Q(QMailStore);
+
+    ENFORCE(QMetaObject::invokeMethod(q, "accountsAdded", Qt::QueuedConnection, Q_ARG(QMailAccountIdList, ids)));
+}
+
+void QMailStorePrivate::accountRemoved(Accounts::AccountId id)
+{
+    // ignore non-email accounts
+    if (!accountValid(id))
+        return;
+
+    const QMailAccountId& qId = QMailAccountId(id);
+    ENFORCE(QMetaObject::invokeMethod(this, "onAccountRemovedFinished", Qt::QueuedConnection, Q_ARG(QMailAccountId, qId)));
+}
+
+void QMailStorePrivate::onAccountRemovedFinished(const QMailAccountId &id)
+{
+    Q_Q (QMailStore);
+    emit q->accountsRemoved(QMailAccountIdList() << id);
+    // remove from cache after the notification, so that it is possible to
+    // know details of the removed account
+    accountCache.remove(id);
+}
+
+void QMailStorePrivate::accountUpdated(Accounts::AccountId id)
+{
+    if (!accountValid(id))
+        return;
+
+    const QMailAccountId& qId = QMailAccountId(id);
+    accountCache.remove(qId);
+    Q_Q(QMailStore);
+    ENFORCE(QMetaObject::invokeMethod(q, "accountsUpdated", Qt::QueuedConnection, Q_ARG(QMailAccountIdList, QMailAccountIdList() << qId)));
+}
+
+bool QMailStorePrivate::accountValid(Accounts::AccountId id) const
+{
+    QSharedPointer<Accounts::Account> account(Accounts::Account::fromId(manager, id, const_cast<QMailStorePrivate*>(this)));
+
+    if (!account) {
+        SSOHandleError(manager->lastError());
+        return false;
+    }
+
+    // Account should already have the type "e-mail",
+    // ignore extra checks
+
+
+    return true;
+}
+#endif
diff --git a/src/libraries/qmfclient/qmailstore_p.h b/src/libraries/qmfclient/qmailstore_p.h
index bf192cf5..17539792 100644
--- a/src/libraries/qmfclient/qmailstore_p.h
+++ b/src/libraries/qmfclient/qmailstore_p.h
@@ -51,6 +51,11 @@
 #include <QCache>
 #include <QTimer>
 
+#ifdef USE_ACCOUNTS_QT
+#include <Accounts/account.h>
+#include "ssoaccountmanager.h"
+#endif
+
 //#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
 //#define QMAILSTORE_USE_RTTI //define if RTTI is available to assist debugging
 
@@ -243,6 +248,11 @@ public:
     static ValueType extractValue(const QVariant& var, const ValueType &defaultValue = ValueType());
 
     enum AttemptResult { Success = 0, Failure, DatabaseFailure };
+
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList searchSSOAccounts(const QMailAccountKey& key, const QMailAccountSortKey& sortKey = QMailAccountSortKey()) const;
+#endif
+
 public slots:
     void unloadDatabase();
     
@@ -336,8 +346,11 @@ private:
     QSqlQuery batchQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor);
 
     bool idValueExists(quint64 id, const QString& table);
-
+#ifdef USE_ACCOUNTS_QT
+    bool idExists(const QMailAccountId& id);
+#else
     bool idExists(const QMailAccountId& id, const QString& table = QString());
+#endif
     bool idExists(const QMailFolderId& id, const QString& table = QString());
     bool idExists(const QMailMessageId& id, const QString& table = QString());
 
@@ -413,6 +426,12 @@ private:
     AttemptResult updateLatestInConversation(quint64 threadId, QMailMessageIdList *messagesUpdated, quint64 *updatedTo = Q_NULLPTR);
     AttemptResult updateLatestInConversation(const QSet<quint64> &threadIds, QMailMessageIdList *messagesUpdated);
 
+#ifdef USE_ACCOUNTS_QT
+    AttemptResult addAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields);
+    AttemptResult updateAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields);
+    AttemptResult accountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, QMap<QString, QString>* fields);
+#endif
+
     AttemptResult addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
     AttemptResult updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
     AttemptResult customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName);
@@ -710,7 +729,11 @@ private:
 
     AttemptResult registerSubject(const QString &baseSubject, quint64 messageId, const QMailMessageId &predecessorId, bool missingAncestor);
 
+#ifdef USE_ACCOUNTS_QT
+    QMailAccount extractAccount(const QSharedPointer<Accounts::Account>& ssoAccount);
+#else
     QMailAccount extractAccount(const QSqlRecord& r);
+#endif
     QMailThread extractThread(const QSqlRecord &r);
     QMailFolder extractFolder(const QSqlRecord& r);
     QMailMessageMetaData extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties = allMessageProperties());
@@ -749,10 +772,26 @@ private:
 
     static void extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties, QMailMessageMetaData* metaData);
 
+#ifdef USE_ACCOUNTS_QT
+    bool accountValid(Accounts::AccountId id) const;
+
+    private Q_SLOTS:
+
+        void accountCreated(Accounts::AccountId id);
+        void accountRemoved(Accounts::AccountId id);
+        void accountUpdated(Accounts::AccountId id);
+        void onAccountRemovedFinished(const QMailAccountId& id);
+#endif
+
 private:
     Q_DECLARE_PUBLIC (QMailStore)
     QMailStore * const q_ptr;
 
+#ifdef USE_ACCOUNTS_QT
+    SSOAccountManager manager;
+    QSharedPointer<Accounts::Account> getEmailAccount(const Accounts::AccountId id);
+#endif
+
     template <typename T, typename KeyType> 
     class Cache
     {
diff --git a/src/libraries/qmfclient/qmfclient.pro b/src/libraries/qmfclient/qmfclient.pro
index 95cd2bd8..6fedb7bd 100644
--- a/src/libraries/qmfclient/qmfclient.pro
+++ b/src/libraries/qmfclient/qmfclient.pro
@@ -2,6 +2,35 @@ TARGET     = QmfClient
 QT         = core dbus sql network core5compat
 CONFIG    += warn_on
 
+# FIXME this will result in prl file having explicit linkage against qt-xml and accounts+signon.
+# Should probably have LIBS_PRIVATE type of usage, but now as there are even some header differences
+# on accounts enabled version, let's just allow the dependency. See also qmfmessageserver.pro
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+
+    HEADERS += ssoaccountmanager.h \
+               ssosessionmanager.h \
+               ssoauthplugin.h
+
+    SOURCES += ssoaccountmanager.cpp \
+               ssosessionmanager.cpp \
+               ssoauthplugin.cpp
+
+    MODULE_PLUGIN_TYPES += ssoauth
+
+    # Install email SSO provider description
+    sso_providers.files = share/email.provider
+    sso_providers.path  = $$QMF_INSTALL_ROOT/share/accounts/providers
+
+    # Install email SSO service description
+    sso_services.files = share/email.service
+    sso_services.path  = $$QMF_INSTALL_ROOT/share/accounts/services
+
+    INSTALLS += sso_providers sso_services
+}
+
 MODULE_PLUGIN_TYPES = \
     contentmanagers \
     crypto
diff --git a/src/libraries/qmfclient/share/email.provider b/src/libraries/qmfclient/share/email.provider
new file mode 100644
index 00000000..b090def6
--- /dev/null
+++ b/src/libraries/qmfclient/share/email.provider
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<provider id="email">
+  <name>Email</name>
+  <icon>image://theme/graphic-service-generic-mail</icon>
+
+  <template>
+    <group name="auth">
+      <setting name="method">password</setting>
+      <setting name="mechanism">password</setting>
+    </group>
+  </template>
+</provider>
diff --git a/src/libraries/qmfclient/share/email.service b/src/libraries/qmfclient/share/email.service
new file mode 100644
index 00000000..9f6ef320
--- /dev/null
+++ b/src/libraries/qmfclient/share/email.service
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<service id="email">
+  <type>e-mail</type>
+  <translations>/usr/share/translations/settings-accounts</translations>
+  <name>settings_accounts-email_service</name>
+  <icon>image://theme/graphic-service-generic-mail</icon>
+  <provider>email</provider>
+
+  <!-- default settings (account settings have precedence over these) -->
+  <template>
+    <setting name="sync_profile_templates" type="as">["syncemail"]</setting>
+    <setting name="type" type="i">0</setting>
+    <setting name="name">Email</setting>
+    <setting name="status" type="i">0</setting>
+    <setting name="signatureEnabled" type="b">true</setting>
+    <setting name="signature"></setting>
+    <setting name="emailaddress"></setting>
+    <setting name="fullName"></setting>
+    <setting name="enabled" type="b">false</setting>
+    <setting name="credentialsCheck" type="b">false</setting>
+    <setting name="canTransmit" type="b">true</setting>
+    <setting name="iconPath" type="s">image://theme/graphic-service-generic-mail</setting>
+    <group name="auth">
+            <setting name="method">password</setting>
+            <setting name="mechanism">password</setting>
+    </group>
+    <!-- Exclude default configuration
+    <pop3>
+      <setting name="server">pop3.example.com</setting>
+      <setting name="port" type="i">143</setting>
+      <setting name="encryption" type="b">false</setting>
+      <setting name="canDelete" type="b">false</setting>
+      <setting name="autoDownload" type="b">false</setting>
+      <setting name="maxSize" type="i">102400</setting>
+      <setting name="checkInterval" type="i">-1</setting>
+      <setting name="intervalCheckRoamingEnabled" type="b">false</setting>
+      <setting name="acceptUntrustedCertificates" type="b">false</setting>
+    </pop3>
+    <imap4>
+       <setting name="server">imap.example.com</setting>
+       <setting name="port" type="i">110</setting>
+       <setting name="encryption" type="b">false</setting>
+       <setting name="canDelete" type="b">false</setting>
+       <setting name="autoDownload" type="b">false</setting>
+       <setting name="maxSize" type="i">102400</setting>
+       <setting name="pushEnabled" type="b">false</setting>
+       <setting name="baseFolder"></setting>
+       <setting name="draftsFolder"></setting>
+       <setting name="trashFolder"></setting>
+       <setting name="junkFolder"></setting>
+       <setting name="checkInterval" type="i">-1</setting>
+       <setting name="intervalCheckRoamingEnabled" type="b">false</setting>
+       <setting name="acceptUntrustedCertificates" type="b">false</setting>
+    </imap4>
+    <smtp>
+       <setting name="address">email@example.com</setting>
+       <setting name="server">smtp.example.com</setting>
+       <setting name="port" type="i">25</setting>
+       <setting name="authentication" type="b">false</setting>
+       <setting name="encryption" type="b">false</setting>
+       <setting name="acceptUntrustedCertificates" type="b">false</setting>
+     </smtp>
+     -->
+  </template>
+</service>
diff --git a/src/libraries/qmfclient/ssoaccountmanager.cpp b/src/libraries/qmfclient/ssoaccountmanager.cpp
new file mode 100644
index 00000000..e113f40b
--- /dev/null
+++ b/src/libraries/qmfclient/ssoaccountmanager.cpp
@@ -0,0 +1,66 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "ssoaccountmanager.h"
+
+using namespace Accounts;
+
+Manager* SSOAccountManager::_manager = 0;
+int SSOAccountManager::_refCount = 0;
+
+SSOAccountManager::SSOAccountManager()
+{
+    if (!_manager) {
+        Q_ASSERT(!_refCount);
+        _manager = new Manager(QLatin1String("e-mail"));
+        _manager->setAbortOnTimeout(true);
+    }
+
+    ++_refCount;
+}
+
+SSOAccountManager::~SSOAccountManager()
+{
+    if (--_refCount == 0) {
+        delete _manager;
+        _manager = 0;
+    }
+}
diff --git a/src/libraries/qmfclient/ssoaccountmanager.h b/src/libraries/qmfclient/ssoaccountmanager.h
new file mode 100644
index 00000000..aa756828
--- /dev/null
+++ b/src/libraries/qmfclient/ssoaccountmanager.h
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SSOACCOUNTMANAGER_H
+#define SSOACCOUNTMANAGER_H
+
+#include <qglobal.h>
+#include "qmailglobal.h"
+
+// Accounts
+#include <Accounts/Manager>
+
+/// Accounts::Manager wrapper.
+class QMF_EXPORT SSOAccountManager
+{
+public:
+    SSOAccountManager();
+    ~SSOAccountManager();
+
+    Accounts::Manager* operator ->() const
+    {
+        Q_ASSERT (_manager);
+        return _manager;
+    }
+
+    operator Accounts::Manager*() const
+    {
+        Q_ASSERT (_manager);
+        return _manager;
+    }
+
+private:
+    Q_DISABLE_COPY (SSOAccountManager);
+    static Accounts::Manager* _manager;
+    static int _refCount;
+};
+#endif // SSOACCOUNTMANAGER_H
diff --git a/src/libraries/qmfclient/ssoauthplugin.cpp b/src/libraries/qmfclient/ssoauthplugin.cpp
new file mode 100644
index 00000000..e085e2d6
--- /dev/null
+++ b/src/libraries/qmfclient/ssoauthplugin.cpp
@@ -0,0 +1,118 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valério Valério <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "ssoauthplugin.h"
+
+#include <QMap>
+#include <QDebug>
+#include <qmailpluginmanager.h>
+
+#define PLUGIN_KEY "ssoauth"
+
+typedef QMap<QString, SSOAuthService*> PluginMap;
+
+// Load all the auth plugins into a map for quicker reference
+static PluginMap initMap(QMailPluginManager& manager)
+{
+    PluginMap map;
+
+    foreach (const QString &item, manager.list()) {
+        QObject *instance = manager.instance(item);
+        if (SSOAuthService* iface = qobject_cast<SSOAuthService*>(instance))
+                map.insert(iface->key(), iface);
+    }
+    return map;
+}
+
+// Return a reference to a map containing all loaded plugin objects
+static PluginMap& pluginMap()
+{
+    static QMailPluginManager pluginManager(PLUGIN_KEY);
+    static PluginMap map(initMap(pluginManager));
+
+    return map;
+}
+
+// Return the auth plugin object matching the specified ID
+static SSOAuthService* mapping(const QString& key)
+{
+    PluginMap::ConstIterator it;
+    if ((it = pluginMap().find(key)) != pluginMap().end())
+        return it.value();
+
+    qWarning() << "Failed attempt to map plugin: " << key;
+    return 0;
+}
+
+SSOAuthService::SSOAuthService(QObject *parent)
+    : QObject(parent)
+{
+}
+
+SSOAuthService::~SSOAuthService()
+{
+}
+
+/*!
+    Returns a list of the keys of the installed plugins.
+ */
+QStringList SSOAuthFactory::keys()
+{
+    QStringList in;
+
+    foreach (PluginMap::mapped_type plugin, pluginMap())
+        in << plugin->key();
+
+    return in;
+}
+
+/*!
+    Creates a plugin object of the class identified by \a key.
+*/
+SSOAuthService* SSOAuthFactory::createService(const QString& key)
+{
+    if (SSOAuthService* plugin = mapping(key))
+        return plugin->createService();
+
+    return 0;
+}
+
+
diff --git a/src/libraries/qmfclient/ssoauthplugin.h b/src/libraries/qmfclient/ssoauthplugin.h
new file mode 100644
index 00000000..faf3713c
--- /dev/null
+++ b/src/libraries/qmfclient/ssoauthplugin.h
@@ -0,0 +1,74 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valério Valério <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SSOAUTHPLUGIN_H
+#define SSOAUTHPLUGIN_H
+
+#include "qmailglobal.h"
+#include <QObject>
+#include <QString>
+#include <QVariantMap>
+#include <SignOn/SessionData>
+
+class QMF_EXPORT SSOAuthService : public QObject
+{
+    Q_OBJECT
+
+public:
+    SSOAuthService(QObject* parent = 0);
+    ~SSOAuthService();
+
+    virtual QString key() const = 0;
+    virtual QList<QByteArray> authentication(const SignOn::SessionData &sessionData,
+                                         const QString &serviceType, const QString &userName, int serviceAuthentication) const = 0;
+    virtual void credentialsNeedUpdate(int accountId) = 0;
+    virtual SignOn::SessionData sessionData(const QString &accountProvider, QVariantMap authParameters) const = 0;
+    virtual SSOAuthService *createService() = 0;
+};
+
+class QMF_EXPORT SSOAuthFactory
+{
+public:
+    static QStringList keys();
+    static SSOAuthService *createService(const QString& key);
+};
+
+#endif // SSOAUTHPLUGIN_H
diff --git a/src/libraries/qmfclient/ssosessionmanager.cpp b/src/libraries/qmfclient/ssosessionmanager.cpp
new file mode 100644
index 00000000..e988ed61
--- /dev/null
+++ b/src/libraries/qmfclient/ssosessionmanager.cpp
@@ -0,0 +1,392 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valério Valério <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "ssosessionmanager.h"
+#include "ssoaccountmanager.h"
+#include <qmaillog.h>
+#include <QTimer>
+
+#include <Accounts/AccountService>
+#include <Accounts/AuthData>
+
+/*!
+    \class SSOSessionManager
+
+    \preliminary
+    \brief The SSOSessionManager class provides a manager to query authentication details
+    from accounts-sso framework.
+    \ingroup messaginglibrary
+*/
+
+/*!
+    \fn ssoSessionError(const QString &error)
+
+    This signal is emitted when we receive a reply to an authentication
+    request from accounts-sso framework and a error occurred, the error
+    details are described by \a error.
+
+    \sa ssoSessionResponse()
+*/
+
+/*!
+    \fn ssoSessionResponse(const QList<QByteArray> &ssoLogin)
+
+    This signal is emitted when we receive a reply to a authentication
+    request from accounts-sso framework, the authentication details are
+    described by \a ssologin.
+
+    \sa ssoSessionError()
+*/
+
+SSOSessionManager::SSOSessionManager(QObject *parent)
+    : QObject(parent),
+      _waitForSso(false),
+      _recreatingSession(false),
+      _reAuthenticate(false),
+      _credentialsCheck(false),
+      _identity(0),
+      _session(0)
+{
+    _availableAuthMethods = SSOAuthFactory::keys();
+}
+
+SSOSessionManager::~SSOSessionManager()
+{
+}
+
+bool SSOSessionManager::authPluginAvailable(const QString &method) const
+{
+    return _availableAuthMethods.contains(method);
+}
+
+/*!
+    Cancels the current session.
+*/
+
+void SSOSessionManager::cancel()
+{
+    if (_waitForSso) {
+        _session->cancel();
+        // Canceled by other process,
+        // no need to emit any error from here.
+        _waitForSso = false;
+    }
+}
+
+/*!
+    Creates a new SSO identity for the account identified by \a id for
+    the service to \a serviceType with the authentication type \a serviceAuthentication.
+
+    Returns true if the account has one email service enabled and a valid identity stored
+    in ths accounts-sso database, otherwise returns false.
+
+    The authentication details will be queried from accounts-sso framework and reported by
+    ssoSessionResponse() signal, if a error occurs it will be reported by ssoSessionError()
+    signal.
+
+    \sa ssoSessionResponse(), ssoSessionError()
+*/
+
+bool SSOSessionManager::createSsoIdentity(const QMailAccountId &id, const QString &serviceType,
+                                          int serviceAuthentication)
+{
+    deleteSsoIdentity();
+    _serviceAuthentication = serviceAuthentication;
+    _serviceType = serviceType;
+    _accountId = id.toULongLong();
+
+    SSOAccountManager manager;
+    QScopedPointer<Accounts::Account> account(Accounts::Account::fromId(manager, static_cast<Accounts::AccountId>(_accountId), this));
+    if (!account)
+        return false;
+
+    Accounts::ServiceList emailServices = account->enabledServices();
+    if (1 != emailServices.count()) {
+        qMailLog(Messaging) << Q_FUNC_INFO << "Account must have one active e-mail service, but it has "
+                       << emailServices.count();
+        return false;
+    }
+
+    account->selectService(emailServices.first());
+    Accounts::AccountService* emailService = new Accounts::AccountService(account.data(), account->selectedService());
+    Accounts::AuthData auth = emailService->authData();
+    delete emailService;
+    _accountProvider = account->providerName();
+    _authMethod = auth.method();
+    _authMechanism = auth.mechanism();
+    _authParameters = auth.parameters();
+
+    if (!authPluginAvailable(_authMethod)) {
+        qMailLog(Messaging) << Q_FUNC_INFO
+                            << "SSO error: No authentication plugin found for the following method: " + _authMethod;
+        return false;
+    }
+
+    quint32 credentialsId = account->valueAsInt(serviceCredentialsId(_serviceType), 0);
+    _authUsername = account->valueAsString(serviceUsername(_serviceType));
+
+    if (_authUsername.isEmpty()) {
+        _authUsername = account->valueAsString("emailaddress");
+    }
+
+    if (_authUsername.isEmpty()) {
+        qMailLog(Messaging) << Q_FUNC_INFO
+                            << "SSO error: User name is emtpy.";
+        return false;
+    }
+
+    _credentialsCheck = account->valueAsBool("credentialsCheck");
+
+    // Some plugins stores an identity per service.
+    // If there is no specific credentials for the specific service than we should check regular credentialsId.
+    // This allows to store different credentials for incoming and outgoing servers for example.
+    if (credentialsId == 0) {
+        credentialsId = account->credentialsId();
+    }
+
+    _identity = SignOn::Identity::existingIdentity(credentialsId, this);
+
+    if (_identity) {
+
+        qMailLog(Messaging) << Q_FUNC_INFO << "Creating SSO identity for the service " << _serviceType
+                            << " from account " << id.toULongLong()
+                            << " using authentication method " << _authMethod;
+       _session = _identity->createSession(_authMethod);
+        Q_ASSERT (_session);
+        ENFORCE(connect(_session, SIGNAL(response(SignOn::SessionData)),
+                        this, SLOT(ssoResponse(SignOn::SessionData))));
+        ENFORCE(connect(_session, SIGNAL(error(SignOn::Error)),
+                        this, SLOT(ssoSessionError(SignOn::Error))));
+        _waitForSso = true;
+        _authService = SSOAuthFactory::createService(_authMethod);
+        _sessionData = _authService->sessionData(_accountProvider, _authParameters);
+        _session->process(_sessionData, _authMechanism);
+        return true;
+    } else {
+        _session = 0;
+        return false;
+    }
+}
+
+/*!
+  Returns true if credentials checking is being performed for this account, otherwise returns false.
+*/
+bool SSOSessionManager::checkingCredentials() const
+{
+    return _credentialsCheck;
+}
+
+/*!
+  Set credentials need update if the plugin supports it.
+*/
+
+void SSOSessionManager::credentialsNeedUpdate()
+{
+    qMailLog(Messaging) << Q_FUNC_INFO << "Setting credentials need update for the service " << _serviceType
+                        << " from account " << _accountId
+                        << " using authentication method " << _authMethod;
+    _authService->credentialsNeedUpdate(_accountId);
+}
+
+/*!
+    Deletes the SSO identity.
+*/
+void SSOSessionManager::deleteSsoIdentity()
+{
+    _ssoLogin = QByteArray();
+    _authMethod.clear();
+    _serviceType.clear();
+    if (_identity) {
+        Q_ASSERT (_session);
+        _identity->destroySession(_session);
+        delete _identity;
+        _identity = 0;
+    }
+}
+
+/*!
+    Recreates the SSO identity.
+
+    This function should be used when stored authentication details
+    are no longer valid.
+*/
+void SSOSessionManager::recreateSsoIdentity()
+{
+    qMailLog(Messaging) << Q_FUNC_INFO << "Recreating SSO identity using auth method "
+                           << _authMethod;
+    if (_identity && _session && !_waitForSso) {
+        if (!_authService)
+            _authService = SSOAuthFactory::createService(_authMethod);
+
+        _waitForSso = true;
+        _recreatingSession = true;
+        _session->process(_sessionData, _authMechanism);
+    } else {
+        _waitForSso = true;
+        emit ssoSessionError("SSO error: Identity is not valid, can't recreate session.");
+    }
+}
+
+void SSOSessionManager::removeSsoIdentity()
+{
+    qWarning() << Q_FUNC_INFO << "unimplemented!";
+}
+
+QString SSOSessionManager::serviceUsername(const QString &serviceType) const
+{
+    if (serviceType == "imap4") {
+        return "imap4/username";
+    } else if (serviceType == "pop3") {
+        return "pop3/username";
+    } else if (serviceType == "smtp") {
+        return "smtp/smtpusername";
+    } else {
+        return QString();
+    }
+
+}
+
+QString SSOSessionManager::serviceCredentialsId(const QString &serviceType) const
+{
+    if (serviceType == "imap4") {
+        return "imap4/CredentialsId";
+    } else if (serviceType == "pop3") {
+        return "pop3/CredentialsId";
+    } else if (serviceType == "smtp") {
+        return "smtp/CredentialsId";
+    } else {
+        return QString();
+    }
+}
+
+void SSOSessionManager::ssoResponse(const SignOn::SessionData &sessionData)
+{
+    if (_waitForSso) {
+        _waitForSso = false;
+        if (!_authService)
+            _authService = SSOAuthFactory::createService(_authMethod);
+
+        if(_authService->key() == "oauth2") {
+            QVariantMap newToken;
+            foreach (const QString &key, sessionData.propertyNames()) {
+                newToken.insert(key, sessionData.getProperty(key));
+            }
+
+            if (_recreatingSession) {
+                if (_oldToken["AccessToken"].toString() != newToken["AccessToken"].toString()
+                        && !newToken["AccessToken"].toString().isEmpty()) {
+                    _recreatingSession = false;
+                    qMailLog(Messaging) << Q_FUNC_INFO << "Recreating SSO identity, authentication token refreshed sucessfully";
+                    _oldToken = newToken;
+                    sessionResponse(sessionData);
+                } else {
+                    _oldToken = newToken;
+                    _recreatingSession = false;
+                    forceTokenRefresh();
+                }
+                return;
+            } else if (_reAuthenticate) {
+                _reAuthenticate = false;
+                QTimer::singleShot(5000, this, SLOT(reAuthenticate()));
+            } else {
+                _oldToken = newToken;
+                sessionResponse(sessionData);
+            }
+        } else {
+            sessionResponse(sessionData);
+        }
+    }
+}
+
+void SSOSessionManager::ssoSessionError(const SignOn::Error &code)
+{
+    if (code.type() == SignOn::Error::InvalidCredentials || code.type() == SignOn::Error:: UserInteraction) {
+        credentialsNeedUpdate();
+    }
+
+    if (_waitForSso) {
+        _waitForSso = false;
+        _ssoLogin = QByteArray();
+        emit ssoSessionError(QString("SSO error %1: %2").arg(code.type()).arg(code.message()));
+    }
+}
+
+void SSOSessionManager::forceTokenRefresh()
+{
+    qMailLog(Messaging) << Q_FUNC_INFO << "Forcing authentication token refresh";
+    QVariantMap providedTokens = _oldToken;
+    providedTokens.insert("ExpiresIn", 1);
+
+    QVariantMap sdvmap(_authParameters);
+    sdvmap.insert("UiPolicy", SignOn::NoUserInteractionPolicy);
+    sdvmap.insert("ClientId", _sessionData.getProperty("ClientId"));
+    sdvmap.insert("ClientSecret", _sessionData.getProperty("ClientSecret"));
+    sdvmap.insert("ProvidedTokens", providedTokens);
+    _refreshSessionData = sdvmap;
+
+    _reAuthenticate = true;
+    _waitForSso = true;
+    _session->process(SignOn::SessionData(sdvmap), _authMechanism);
+}
+
+void SSOSessionManager::reAuthenticate()
+{
+    qMailLog(Messaging) << Q_FUNC_INFO << "Re-authenticating with SSO after token refresh";
+    _waitForSso = true;
+    _session->process(_sessionData, _authMechanism);
+}
+
+void SSOSessionManager::sessionResponse(const SignOn::SessionData &sessionData)
+{
+    QList<QByteArray> ssoLogin = _authService->authentication(sessionData, _serviceType,
+                                                          _authUsername, _serviceAuthentication);
+    emit ssoSessionResponse(ssoLogin);
+}
+
+/*!
+    Returns true if we are waiting for a reply
+    from accounts-sso framework, otherwise false.
+*/
+bool SSOSessionManager::waitForSso()
+{
+    return _waitForSso;
+}
+
diff --git a/src/libraries/qmfclient/ssosessionmanager.h b/src/libraries/qmfclient/ssosessionmanager.h
new file mode 100644
index 00000000..eaecf916
--- /dev/null
+++ b/src/libraries/qmfclient/ssosessionmanager.h
@@ -0,0 +1,115 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Jolla Ltd.
+** Contact: Valério Valério <valerio.valerio@jollamobile.com>
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef SSOSESSIONMANAGER_H
+#define SSOSESSIONMANAGER_H
+
+#include "ssoauthplugin.h"
+#include "qmailglobal.h"
+#include "qmailaccount.h"
+#include <QString>
+#include <qglobal.h>
+
+// Accounts
+#include <Accounts/Account>
+#include <SignOn/Identity>
+#include <SignOn/SessionData>
+
+using namespace SignOn;
+
+class QMF_EXPORT SSOSessionManager : public QObject
+{
+    Q_OBJECT
+public:
+    SSOSessionManager(QObject* parent);
+    ~SSOSessionManager();
+
+    void cancel();
+    bool createSsoIdentity(const QMailAccountId &id,
+                           const QString &serviceType, int serviceAuthentication);
+    bool checkingCredentials() const;
+    void credentialsNeedUpdate();
+    void deleteSsoIdentity();
+    void recreateSsoIdentity();
+    void removeSsoIdentity();
+    bool waitForSso();
+
+signals:
+    void ssoSessionResponse(const QList<QByteArray> &ssoLogin);
+    void ssoSessionError(const QString &error);
+
+protected slots:
+    void ssoResponse(const SignOn::SessionData &sessionData);
+    void ssoSessionError(const SignOn::Error &code);
+
+private slots:
+    void reAuthenticate();
+
+private:
+    bool authPluginAvailable(const QString &method) const;
+    QString serviceUsername(const QString &serviceType) const;
+    QString serviceCredentialsId(const QString &serviceType) const;
+    void forceTokenRefresh();
+    void sessionResponse(const SignOn::SessionData &sessionData);
+
+    int _serviceAuthentication;
+    int _accountId;
+    bool _waitForSso;
+    bool _recreatingSession;
+    bool _reAuthenticate;
+    bool _credentialsCheck;
+    QByteArray _ssoLogin;
+    QString _authMethod;
+    QString _authMechanism;
+    QString _authUsername;
+    QVariantMap _authParameters;
+    QString _serviceType;
+    QString _accountProvider;
+    QStringList _availableAuthMethods;
+    SSOAuthService *_authService;
+    SignOn::Identity *_identity;
+    SignOn::AuthSession *_session;
+    SignOn::SessionData _sessionData;
+    QVariantMap _oldToken;
+    QVariantMap _refreshSessionData;
+};
+
+#endif // SSOSESSIONMANAGER_H
diff --git a/src/libraries/qmfmessageserver/qmailauthenticator.cpp b/src/libraries/qmfmessageserver/qmailauthenticator.cpp
index 83ecfb7c..92a12e70 100644
--- a/src/libraries/qmfmessageserver/qmailauthenticator.cpp
+++ b/src/libraries/qmfmessageserver/qmailauthenticator.cpp
@@ -130,6 +130,23 @@ QByteArray QMailAuthenticator::getAuthentication(const QMailAccountConfiguration
     should be decoded before invocation, and the result should be encoded for
     transmission.
 */
+#ifdef USE_ACCOUNTS_QT
+QByteArray QMailAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, QString password)
+{
+    QMailServiceConfiguration configuration(svcCfg);
+    if (!configuration.value("smtpusername").isEmpty()
+        && (configuration.value("authentication") == QString::number(QMail::CramMd5Mechanism))) {
+        // SMTP server CRAM-MD5 authentication
+        return cramMd5Response(challenge, configuration.value("smtpusername").toUtf8(), password.toUtf8());
+    } else if (configuration.value("authentication") == QString::number(QMail::CramMd5Mechanism)) {
+        // IMAP/POP server CRAM-MD5 authentication
+        return cramMd5Response(challenge, configuration.value("username").toUtf8(), password.toUtf8());
+    }
+
+    // Unknown service type and/or authentication type
+    return QByteArray();
+}
+#else
 QByteArray QMailAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge)
 {
     QMailServiceConfiguration configuration(svcCfg);
@@ -147,4 +164,4 @@ QByteArray QMailAuthenticator::getResponse(const QMailAccountConfiguration::Serv
     // Unknown service type and/or authentication type
     return QByteArray();
 }
-
+#endif
diff --git a/src/libraries/qmfmessageserver/qmailauthenticator.h b/src/libraries/qmfmessageserver/qmailauthenticator.h
index 287bd1f3..a9f2d214 100644
--- a/src/libraries/qmfmessageserver/qmailauthenticator.h
+++ b/src/libraries/qmfmessageserver/qmailauthenticator.h
@@ -44,7 +44,11 @@ class MESSAGESERVER_EXPORT QMailAuthenticator
 public:
     static bool useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
     static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#ifdef USE_ACCOUNTS_QT
+    static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, QString password);
+#else
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+#endif
 };
 
 #endif
diff --git a/src/libraries/qmfmessageserver/qmfmessageserver.pro b/src/libraries/qmfmessageserver/qmfmessageserver.pro
index b042ba2b..62d1e28d 100644
--- a/src/libraries/qmfmessageserver/qmfmessageserver.pro
+++ b/src/libraries/qmfmessageserver/qmfmessageserver.pro
@@ -39,3 +39,12 @@ SOURCES += qmailauthenticator.cpp \
            qmailtransport.cpp \
            qmailheartbeattimer_qtimer.cpp # NB: There are multiple implementations
 
+
+# FIXME this will result in prl file having explicit linkage against qt-xml and accounts+signon.
+# Should probably have LIBS_PRIVATE type of usage, but now as there are even some header differences
+# on accounts enabled version, let's just allow the dependency. See also qmfclient.pro
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
diff --git a/src/libraries/qmfwidgets/qmfwidgets.pro b/src/libraries/qmfwidgets/qmfwidgets.pro
index ddff356e..dafd090a 100644
--- a/src/libraries/qmfwidgets/qmfwidgets.pro
+++ b/src/libraries/qmfwidgets/qmfwidgets.pro
@@ -41,3 +41,9 @@ TRANSLATIONS += libqmfutil-ar.ts \
 
 RESOURCES += qmfutil.qrc
 
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
diff --git a/src/plugins/messageservices/imap/imap.pro b/src/plugins/messageservices/imap/imap.pro
index 42c0151b..6c161169 100644
--- a/src/plugins/messageservices/imap/imap.pro
+++ b/src/plugins/messageservices/imap/imap.pro
@@ -10,6 +10,13 @@ contains(DEFINES,QT_QMF_USE_ALIGNEDTIMER) {
     QT += alignedtimer
 }
 
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
+
 HEADERS += imapclient.h \
            imapconfiguration.h \
            imapmailboxproperties.h \
diff --git a/src/plugins/messageservices/imap/imapauthenticator.cpp b/src/plugins/messageservices/imap/imapauthenticator.cpp
index 23deb562..941801dd 100644
--- a/src/plugins/messageservices/imap/imapauthenticator.cpp
+++ b/src/plugins/messageservices/imap/imapauthenticator.cpp
@@ -39,6 +39,7 @@
 #include <qmailauthenticator.h>
 #include <qmailtransport.h>
 #include <qmailnamespace.h>
+#include <qmaillog.h>
 
 namespace {
 
@@ -69,7 +70,44 @@ bool ImapAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceCo
     return QMailAuthenticator::useEncryption(svcCfg, capabilities);
 #endif
 }
+#ifdef USE_ACCOUNTS_QT
+QByteArray ImapAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QByteArray &ssoLogin)
+{
+    QString _password;
+    QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!result.isEmpty())
+        return QByteArray("AUTHENTICATE ") + result;
+
+    // If not handled by the authenticator, fall back to login
+    ImapConfiguration imapCfg(svcCfg);
+    if (ssoLogin.isEmpty()) {
+        _password = imapCfg.mailPassword();
+        qMailLog(IMAP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< imapCfg.id()
+                       << ", using password from accounts configuration";
+    } else {
+        return ssoLogin;
+    }
 
+    if (imapCfg.mailAuthentication() == QMail::PlainMechanism) {
+        QByteArray username(imapCfg.mailUserName().toLatin1());
+        QByteArray pass(_password.toLatin1());
+        return QByteArray("AUTHENTICATE PLAIN ") + QByteArray(username + '\0' + username + '\0' + pass).toBase64();
+    }
+
+    return QByteArray("LOGIN") + ' ' + ImapProtocol::quoteString(imapCfg.mailUserName().toLatin1())
+                               + ' ' + ImapProtocol::quoteString(_password.toLatin1());
+}
+
+QByteArray ImapAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, const QByteArray &ssoLogin)
+{
+    if (ssoLogin.size()) {
+        return QMailAuthenticator::getResponse(svcCfg, challenge, QString::fromLatin1(ssoLogin.constData()));
+    } else {
+        return QByteArray();
+    }
+}
+
+#else
 QByteArray ImapAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
     QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
@@ -92,4 +130,5 @@ QByteArray ImapAuthenticator::getResponse(const QMailAccountConfiguration::Servi
 {
     return QMailAuthenticator::getResponse(svcCfg, challenge);
 }
+#endif
 
diff --git a/src/plugins/messageservices/imap/imapauthenticator.h b/src/plugins/messageservices/imap/imapauthenticator.h
index 3a9bdf8d..879629ff 100644
--- a/src/plugins/messageservices/imap/imapauthenticator.h
+++ b/src/plugins/messageservices/imap/imapauthenticator.h
@@ -43,8 +43,14 @@ class ImapAuthenticator
 {
 public:
     static bool useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#ifdef USE_ACCOUNTS_QT
+    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QByteArray &ssoLogin);
+    static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, const QByteArray &ssoLogin);
+#else
     static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+#endif
+
 };
 
 #endif
diff --git a/src/plugins/messageservices/imap/imapclient.cpp b/src/plugins/messageservices/imap/imapclient.cpp
index a4100fb7..a4293a63 100644
--- a/src/plugins/messageservices/imap/imapclient.cpp
+++ b/src/plugins/messageservices/imap/imapclient.cpp
@@ -182,16 +182,23 @@ class IdleProtocol : public ImapProtocol {
     Q_OBJECT
 
 public:
+#ifdef USE_ACCOUNTS_QT
+    IdleProtocol(ImapClient *client, const QMailFolder &folder, const bool ssoAccount, QByteArray &ssoLogin);
+#else
     IdleProtocol(ImapClient *client, const QMailFolder &folder);
+#endif
     virtual ~IdleProtocol() {}
 
     virtual void handleIdling() { _client->idling(_folder.id()); }
     virtual bool open(const ImapConfiguration& config, qint64 bufferSize = 10*1024);
+#ifdef USE_ACCOUNTS_QT
+    int idleRetryDelay() { return _idleRetryDelay; }
+#endif
 
 signals:
     void idleNewMailNotification(QMailFolderId);
     void idleFlagsChangedNotification(QMailFolderId);
-    void openRequest();
+    void openRequest(IdleProtocol*);
 
 protected slots:
     virtual void idleContinuation(ImapCommand, const QString &);
@@ -211,9 +218,22 @@ private:
     QTimer _idleTimer; // Send a DONE command every 29 minutes
 #endif
     QTimer _idleRecoveryTimer; // Check command hasn't hung
+#ifdef USE_ACCOUNTS_QT
+    int _idleRetryDelay; // Try to restablish IDLE state
+    enum IdleRetryDelay { InitialIdleRetryDelay = 30 }; //seconds
+    bool _ssoAccount;
+    QByteArray &_ssoLogin;
+#endif
 };
 
+#ifdef USE_ACCOUNTS_QT
+IdleProtocol::IdleProtocol(ImapClient *client, const QMailFolder &folder, const bool ssoAccount, QByteArray &ssoLogin)
+    : _idleRetryDelay(InitialIdleRetryDelay),
+      _ssoAccount(ssoAccount),
+      _ssoLogin(ssoLogin)
+#else
 IdleProtocol::IdleProtocol(ImapClient *client, const QMailFolder &folder)
+#endif
 {
     _client = client;
     _folder = folder;
@@ -310,14 +330,28 @@ void IdleProtocol::idleCommandTransition(const ImapCommand command, const Operat
                     break;
                 }
             }
-
+#ifdef USE_ACCOUNTS_QT
+            // We are now connected
+            if (_ssoAccount)
+                sendLogin(config, _ssoLogin);
+            else
+                sendLogin(config, "");
+#else
             // We are now connected
             sendLogin(config);
+#endif
             return;
         }
         case IMAP_StartTLS:
         {
+#ifdef USE_ACCOUNTS_QT
+        if (_ssoAccount)
+            sendLogin(config, _ssoLogin);
+        else
+            sendLogin(config, "");
+#else
             sendLogin(config);
+#endif
             break;
         }
         case IMAP_Login: // Fall through
@@ -385,9 +419,23 @@ void IdleProtocol::idleErrorRecovery()
     const int oneHour = 60*60;
     _idleRecoveryTimer.stop();
 
-    _client->setIdleRetryDelay(qMin( oneHour, _client->idleRetryDelay()*2 ));
+#ifdef USE_ACCOUNTS_QT
+    if (connected() && _idleTimer.isActive()) {
+        qMailLog(IMAP) << objectName() << "IDLE: IMAP IDLE error recovery was successful. About to check for new mail.";
+        _idleRetryDelay = InitialIdleRetryDelay;
+        emit idleNewMailNotification(_folder.id()); // Check for new messages arriving while idle connection was down
+        emit idleFlagsChangedNotification(_folder.id());
+        return;
+    }
+    updateStatus(tr("Idle Error occurred"));
 
-    emit openRequest();
+    QTimer::singleShot(_idleRetryDelay*1000, this, SLOT(idleErrorRecovery()));
+    _idleRetryDelay = qMin( oneHour, _idleRetryDelay*2 );
+
+#else
+    _client->setIdleRetryDelay(qMin( oneHour, _client->idleRetryDelay()*2 ));
+#endif
+    emit openRequest(this);
 }
 
 ImapClient::ImapClient(QObject* parent)
@@ -400,6 +448,12 @@ ImapClient::ImapClient(QObject* parent)
       _rapidClosing(false),
       _idleRetryDelay(InitialIdleRetryDelay),
       _pushConnectionsReserved(0)
+#ifdef USE_ACCOUNTS_QT
+    , _ssoSessionManager(0),
+      _loginFailed(false),
+      _sendLogin(false),
+      _recreateIdentity(true)
+#endif
 {
     static int count(0);
     ++count;
@@ -449,6 +503,9 @@ ImapClient::ImapClient(QObject* parent)
             this, SLOT(connectionInactive()));
 
     connect(QMailMessageBuffer::instance(), SIGNAL(flushed()), this, SLOT(messageBufferFlushed()));
+#ifdef USE_ACCOUNTS_QT
+    connect(QMailStore::instance(), SIGNAL(accountsUpdated(QMailAccountIdList)), this, SLOT(onAccountsUpdated(QMailAccountIdList)));
+#endif
 }
 
 ImapClient::~ImapClient()
@@ -466,6 +523,10 @@ ImapClient::~ImapClient()
         QMailMessageBuffer::instance()->removeCallback(callback);
     }
     delete _strategyContext;
+#ifdef USE_ACCOUNTS_QT
+    if (_ssoSessionManager)
+        _ssoSessionManager->deleteSsoIdentity();
+#endif
 }
 
 // Called to begin executing a strategy
@@ -539,8 +600,28 @@ void ImapClient::checkCommandResponse(ImapCommand command, OperationStatus statu
 
             case IMAP_Login:
             {
+#ifdef USE_ACCOUNTS_QT
+                // We try only once to recreate the sso identity and relogin,
+                // in order to allow user interaction if defined by the sso
+                // plugin.
+                if (_ssoSessionManager && _ssoSessionManager->checkingCredentials()) {
+                    operationFailed(QMailServiceAction::Status::ErrLoginFailed, _protocol.lastError());
+                    return;
+                } else if (!_loginFailed && _recreateIdentity) {
+                    _loginFailed = true;
+                    _sendLogin = true;
+                    ssoProcessLogin();
+                    return;
+                } else {
+                    _recreateIdentity = true;
+                    ssoCredentialsNeedUpdate();
+                    operationFailed(QMailServiceAction::Status::ErrLoginFailed, _protocol.lastError());
+                    return;
+                }
+#else
                 operationFailed(QMailServiceAction::Status::ErrLoginFailed, _protocol.lastError());
                 return;
+#endif
             }
 
             case IMAP_Full:
@@ -571,6 +652,12 @@ void ImapClient::checkCommandResponse(ImapCommand command, OperationStatus statu
         case IMAP_Unconnected:
             operationFailed(QMailServiceAction::Status::ErrNoConnection, _protocol.lastError());
             return;
+#ifdef USE_ACCOUNTS_QT
+        case IMAP_Login:
+            _loginFailed = false;
+            _recreateIdentity = true;
+            break;
+#endif
         default:
             break;
     }
@@ -631,7 +718,15 @@ void ImapClient::commandTransition(ImapCommand command, OperationStatus status)
                     }
                 }
                 emit updateStatus( tr("Logging in" ) );
+#ifdef USE_ACCOUNTS_QT
+                if (_ssoSessionManager) {
+                    _sendLogin = true;
+                    ssoProcessLogin();
+                } else
+                    _protocol.sendLogin(_config, "");
+#else
                 _protocol.sendLogin(_config);
+#endif
             }
             break;
         }
@@ -639,7 +734,15 @@ void ImapClient::commandTransition(ImapCommand command, OperationStatus status)
         case IMAP_Idle_Continuation:
         {
             emit updateStatus( tr("Logging in" ) );
+#ifdef USE_ACCOUNTS_QT
+            if (_ssoSessionManager) {
+                _sendLogin = true;
+                ssoProcessLogin();
+            } else
+                _protocol.sendLogin(_config, "");
+#else
             _protocol.sendLogin(_config);
+#endif
             break;
         }
         
@@ -678,9 +781,16 @@ void ImapClient::commandTransition(ImapCommand command, OperationStatus status)
                 account.setStatus(QMailAccount::CanReferenceExternalData, supportsReferences);
                 imapCfg.setPushCapable(_protocol.supportsCapability("IDLE"));
                 imapCfg.setCapabilities(_protocol.capabilities());
+#ifdef USE_ACCOUNTS_QT
+                if ((!QMailStore::instance()->updateAccount(&account)) ||
+                    (!QMailStore::instance()->updateAccount(&account, &_config))) {
+                    qWarning() << "Unable to update account" << account.id() << "to set imap4 configuration";
+                }
+#else
                 if (!QMailStore::instance()->updateAccount(&account, &_config)) {
                     qWarning() << "Unable to update account" << account.id() << "to set imap4 configuration";
                 }
+#endif
             }
             // After logging in server capabilities reported may change so we need to
             // check if IDLE is already established, when enabled
@@ -1488,6 +1598,25 @@ void ImapClient::setAccount(const QMailAccountId &id)
             qMailLog(Messaging) << "Disable HasPersistentConnection for account" << account.id();
         }
     }
+
+#ifdef USE_ACCOUNTS_QT
+    if (!_ssoSessionManager) {
+        ImapConfiguration imapCfg(_config);
+        _ssoSessionManager = new SSOSessionManager(this);
+         if (_ssoSessionManager->createSsoIdentity(id, "imap4", imapCfg.mailAuthentication())) {
+             ENFORCE(connect(_ssoSessionManager, SIGNAL(ssoSessionResponse(QList<QByteArray>))
+                             ,this, SLOT(onSsoSessionResponse(QList<QByteArray>))));
+             ENFORCE(connect(_ssoSessionManager, SIGNAL(ssoSessionError(QString))
+                             ,this, SLOT(onSsoSessionError(QString))));
+             qMailLog(IMAP) << Q_FUNC_INFO << "SSO identity is found for account id: "<< id;
+         } else {
+             delete _ssoSessionManager;
+             _ssoSessionManager = 0;
+             qMailLog(IMAP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                            << ", accounts configuration will be used";
+         }
+    }
+#endif
 }
 
 QMailAccountId ImapClient::account() const
@@ -1521,6 +1650,11 @@ void ImapClient::transportStatus(const QString& status)
 void ImapClient::cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text)
 {
     operationFailed(code, text);
+#ifdef USE_ACCOUNTS_QT
+    if (_ssoSessionManager) {
+        _ssoSessionManager->cancel();
+    }
+#endif
 }
 
 void ImapClient::retrieveOperationCompleted()
@@ -1707,27 +1841,39 @@ void ImapClient::monitor(const QMailFolderIdList &mailboxIds)
     foreach(QMailFolderId id, mailboxIds) {
         if (!_monitored.contains(id)) {
             ++count;
+#ifdef USE_ACCOUNTS_QT
+            bool ssoAccount = _ssoSessionManager != 0;
+            IdleProtocol *protocol = new IdleProtocol(this, QMailFolder(id), ssoAccount, _ssoLogin);
+#else
             IdleProtocol *protocol = new IdleProtocol(this, QMailFolder(id));
+#endif
             protocol->setObjectName(QString("I:%1").arg(count));
             _monitored.insert(id, protocol);
             connect(protocol, SIGNAL(idleNewMailNotification(QMailFolderId)),
                     this, SIGNAL(idleNewMailNotification(QMailFolderId)));
             connect(protocol, SIGNAL(idleFlagsChangedNotification(QMailFolderId)),
                     this, SIGNAL(idleFlagsChangedNotification(QMailFolderId)));
-            connect(protocol, SIGNAL(openRequest()),
-                    this, SLOT(idleOpenRequested()));
+            connect(protocol, SIGNAL(openRequest(IdleProtocol *)),
+                    this, SLOT(idleOpenRequested(IdleProtocol *)));
             protocol->open(imapCfg);
         }
     }
 }
 
-void ImapClient::idleOpenRequested()
+void ImapClient::idleOpenRequested(IdleProtocol *idleProtocol)
 {
     if (_protocol.inUse()) { // Setting up new idle connection may be in progress
-        qMailLog(IMAP) << _protocol.objectName() 
-                       << "IDLE: IMAP IDLE error recovery detected that the primary connection is "
-                          "busy. Retrying to establish IDLE state in" 
-                       << idleRetryDelay()/2 << "seconds.";
+#ifdef USE_ACCOUNTS_QT
+        qMailLog(IMAP) << _protocol.objectName()
+               << "IDLE: IMAP IDLE error recovery detected that the primary connection is "
+                  "busy. Retrying to establish IDLE state in"
+               << idleProtocol->idleRetryDelay()/2 << "seconds.";
+#else
+        qMailLog(IMAP) << _protocol.objectName()
+               << "IDLE: IMAP IDLE error recovery detected that the primary connection is "
+                  "busy. Retrying to establish IDLE state in"
+               << idleRetryDelay()/2 << "seconds.";
+#endif
         return;
     }
     _protocol.close();
@@ -1738,7 +1884,7 @@ void ImapClient::idleOpenRequested()
         delete protocol;
     }
     _idlesEstablished = false;
-    qMailLog(IMAP) << _protocol.objectName() 
+    qMailLog(IMAP) << _protocol.objectName()
                    << "IDLE: IMAP IDLE error recovery trying to establish IDLE state now.";
     emit restartPushEmail();
 }
@@ -1768,4 +1914,130 @@ void ImapClient::removeAllFromBuffer(QMailMessage *message)
     }
 }
 
+#ifdef USE_ACCOUNTS_QT
+void ImapClient::removeSsoIdentity(const QMailAccountId &accountId)
+{
+    //removing sso Identity
+    if (_config.id() == accountId) {
+        if (_ssoSessionManager) {
+            _ssoSessionManager->removeSsoIdentity();
+            delete _ssoSessionManager;
+            _ssoSessionManager = 0;
+        }
+    }
+}
+
+void ImapClient::ssoProcessLogin()
+{
+    if (_loginFailed && _recreateIdentity) {
+        // if account was updated try to recreate
+        // identity without asking the user for new
+        // credentials
+        if (_ssoSessionManager)
+            _ssoSessionManager->recreateSsoIdentity();
+        else
+            operationFailed(QMailServiceAction::Status::ErrLoginFailed, "SSO Error: can't recreate identity.");
+    } else {
+        if (_sendLogin && !_ssoSessionManager->waitForSso()) {
+            _sendLogin = false;
+            _protocol.sendLogin(_config, _ssoLogin);
+        } else {
+            qMailLog(IMAP) << Q_FUNC_INFO << "Waiting for SSO...";
+        }
+    }
+}
+
+void ImapClient::ssoCredentialsNeedUpdate()
+{
+    if (_ssoSessionManager) {
+        _ssoSessionManager->credentialsNeedUpdate();
+    } else {
+        qMailLog(IMAP) << Q_FUNC_INFO << "SSO Error: can't set credentials need update.";
+    }
+}
+
+void ImapClient::onSsoSessionResponse(const QList<QByteArray> &ssoLogin)
+{
+    qMailLog(IMAP)  << "Got SSO response";
+    if (!ssoLogin.isEmpty()) {
+        if (_ssoLogin != ssoLogin[0]) {
+            _ssoLogin = ssoLogin[0];
+        } else {
+            _ssoLogin = ssoLogin[0];
+        }
+    }
+
+    if (_loginFailed) {
+        _recreateIdentity = false;
+        commandTransition(IMAP_Init, OpPending);
+        return;
+    }
+    if (_sendLogin) {
+        _protocol.sendLogin(_config, _ssoLogin);
+    }
+}
+
+void ImapClient::onSsoSessionError(const QString &error)
+{
+    // Reset vars
+    _loginFailed = false;
+    _sendLogin = false;
+    _recreateIdentity = true;
+    qMailLog(IMAP) <<  "Got SSO error:" << error;
+    operationFailed(QMailServiceAction::Status::ErrLoginFailed, error);
+}
+
+void ImapClient::onAccountsUpdated(const QMailAccountIdList &list)
+{
+    if (list.contains(_config.id())) {
+
+        ImapConfiguration imapCfg1(_config);
+        // copying here as the data is shared
+        QMailAccountConfiguration config = QMailAccountConfiguration(_config.id());
+        ImapConfiguration imapCfg2(config);
+
+        if (!imapCfg1.isValid()) {
+            qMailLog(IMAP) << Q_FUNC_INFO << "current config is invalid";
+            return;
+        }
+
+        if (!imapCfg2.isValid()) {
+            qMailLog(IMAP) << Q_FUNC_INFO << "invalid config from db";
+            return;
+        }
+
+        qMailLog(IMAP) << Q_FUNC_INFO << imapCfg1.mailUserName() ;
+        // compare config modified by the User
+        const bool& notEqual = (imapCfg1.mailUserName() != imapCfg2.mailUserName()) ||
+                               (imapCfg1.mailPassword() != imapCfg2.mailPassword()) ||
+                               (imapCfg1.mailServer() != imapCfg2.mailServer()) ||
+                               (imapCfg1.mailPort() != imapCfg2.mailPort()) ||
+                               (imapCfg1.mailEncryption() != imapCfg2.mailEncryption()) ||
+                               (imapCfg1.pushEnabled() != imapCfg2.pushEnabled());
+        if (notEqual)
+            closeIdleConnections();
+
+        if (imapCfg1.pushEnabled() != imapCfg2.pushEnabled()) {
+            if (imapCfg2.pushEnabled())
+                emit restartPushEmail();
+        }
+    }
+}
+
+void ImapClient::closeIdleConnections()
+{
+    qMailLog(IMAP) << Q_FUNC_INFO << "Account was modified. Closing connections";
+
+    closeConnection();
+    // closing idle connections
+    foreach(const QMailFolderId &id, _monitored.keys()) {
+        IdleProtocol *protocol = _monitored.take(id);
+        protocol->close();
+        delete protocol;
+    }
+    _idlesEstablished = false;
+}
+
+#endif
+
 #include "imapclient.moc"
diff --git a/src/plugins/messageservices/imap/imapclient.h b/src/plugins/messageservices/imap/imapclient.h
index c0ec295c..fa9079d0 100644
--- a/src/plugins/messageservices/imap/imapclient.h
+++ b/src/plugins/messageservices/imap/imapclient.h
@@ -47,6 +47,10 @@
 #include <qmailmessageclassifier.h>
 #include <qmailmessageserver.h>
 
+#ifdef USE_ACCOUNTS_QT
+#include <ssosessionmanager.h>
+#endif
+
 
 class ImapStrategy;
 class ImapStrategyContext;
@@ -62,6 +66,10 @@ public:
     ~ImapClient();
 
     void setAccount(const QMailAccountId& accountId);
+#ifdef USE_ACCOUNTS_QT
+    void removeSsoIdentity(const QMailAccountId& accountId);
+    void closeIdleConnections();
+#endif
     QMailAccountId account() const;
     void requestRapidClose() { _requestRapidClose = true; } // Close connection ASAP, unless interactive checking occurred recently
 
@@ -141,12 +149,22 @@ protected slots:
     void checkCommandResponse(const ImapCommand, const OperationStatus);
     void commandTransition(const ImapCommand, const OperationStatus);
     void transportStatus(const QString& status);
-    void idleOpenRequested();
+    void idleOpenRequested(IdleProtocol*);
     void messageBufferFlushed();
 
+#ifdef USE_ACCOUNTS_QT
+    void onAccountsUpdated(const QMailAccountIdList& list);
+    void onSsoSessionError(const QString &error);
+    void onSsoSessionResponse(const QList<QByteArray> &ssoLogin);
+#endif
+
 private:
     friend class ImapStrategyContextBase;
 
+#ifdef USE_ACCOUNTS_QT
+    void ssoProcessLogin();
+    void ssoCredentialsNeedUpdate();
+#endif
     void deactivateConnection();
     void retrieveOperationCompleted();
 
@@ -180,6 +198,14 @@ private:
     int _pushConnectionsReserved;
 
     QMultiMap<QMailMessageId,QString> detachedTempFiles;
+
+#ifdef USE_ACCOUNTS_QT
+    SSOSessionManager* _ssoSessionManager;
+    bool _loginFailed;
+    bool _sendLogin;
+    bool _recreateIdentity;
+    QByteArray _ssoLogin;
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/imap/imapprotocol.cpp b/src/plugins/messageservices/imap/imapprotocol.cpp
index 807b7ec5..2cb21893 100644
--- a/src/plugins/messageservices/imap/imapprotocol.cpp
+++ b/src/plugins/messageservices/imap/imapprotocol.cpp
@@ -560,8 +560,11 @@ class LoginState : public ImapState
 public:
     LoginState() : ImapState(IMAP_Login, "Login") { LoginState::init(); }
 
+#ifdef USE_ACCOUNTS_QT
+    void setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities, const QByteArray &ssoLogin);
+#else
     void setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities);
-
+#endif
     virtual void init();
     virtual QString transmit(ImapContext *c);
     virtual bool continuationResponse(ImapContext *c, const QString &line);
@@ -570,34 +573,60 @@ public:
 private:
     QMailAccountConfiguration _config;
     QStringList _capabilities;
+#ifdef USE_ACCOUNTS_QT
+    QByteArray _ssoLogin;
+#endif
 };
 
+#ifdef USE_ACCOUNTS_QT
+void LoginState::setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities, const QByteArray &ssoLogin)
+{
+    _config = config;
+    _capabilities = capabilities;
+    _ssoLogin = ssoLogin;
+}
+#else
 void LoginState::setConfiguration(const QMailAccountConfiguration &config, const QStringList &capabilities)
 {
     _config = config;
     _capabilities = capabilities;
 }
+#endif
 
 void LoginState::init()
 {
     ImapState::init();
     _config = QMailAccountConfiguration();
     _capabilities = QStringList();
+#ifdef USE_ACCOUNTS_QT
+    _ssoLogin = QByteArray();
+#endif
 }
 
 QString LoginState::transmit(ImapContext *c)
 {
+#ifdef USE_ACCOUNTS_QT
+    return c->sendCommand(ImapAuthenticator::getAuthentication(_config.serviceConfiguration("imap4"), _capabilities, _ssoLogin));
+#else
     return c->sendCommand(ImapAuthenticator::getAuthentication(_config.serviceConfiguration("imap4"), _capabilities));
+#endif
 }
 
 bool LoginState::continuationResponse(ImapContext *c, const QString &received)
 {
     // The server input is Base64 encoded
     QByteArray challenge = QByteArray::fromBase64(received.toLatin1());
+#ifdef USE_ACCOUNTS_QT
+    QByteArray response(ImapAuthenticator::getResponse(_config.serviceConfiguration("imap4"), challenge, _ssoLogin));
+#else
     QByteArray response(ImapAuthenticator::getResponse(_config.serviceConfiguration("imap4"), challenge));
-
+#endif
     if (!response.isEmpty()) {
         c->sendData(response.toBase64(), true);
+    } else {
+        // Challenge response is empty
+        // send a empty response.
+        c->sendData("");
     }
 
     return false;
@@ -3199,11 +3228,19 @@ void ImapProtocol::sendStartTLS()
     _fsm->setState(&_fsm->startTlsState);
 }
 
+#ifdef USE_ACCOUNTS_QT
+void ImapProtocol::sendLogin(const QMailAccountConfiguration &config , const QByteArray &ssoLogin)
+{
+    _fsm->loginState.setConfiguration(config, _capabilities, ssoLogin);
+    _fsm->setState(&_fsm->loginState);
+}
+#else
 void ImapProtocol::sendLogin( const QMailAccountConfiguration &config )
 {
     _fsm->loginState.setConfiguration(config, _capabilities);
     _fsm->setState(&_fsm->loginState);
 }
+#endif
 
 void ImapProtocol::sendLogout()
 {
@@ -3826,7 +3863,7 @@ QString ImapProtocol::quoteString(const QString& input)
 
 QByteArray ImapProtocol::quoteString(const QByteArray& input)
 {
-    return quoteString(QString(input)).toLatin1();
+    return quoteString(QString::fromLatin1(input)).toLatin1();
 }
 
 void ImapProtocol::createMail(const QString &uid, const QDateTime &timeStamp, int size, uint flags, const QString &detachedFile, const QStringList& structure)
diff --git a/src/plugins/messageservices/imap/imapprotocol.h b/src/plugins/messageservices/imap/imapprotocol.h
index c7dc4dee..d3147ea4 100644
--- a/src/plugins/messageservices/imap/imapprotocol.h
+++ b/src/plugins/messageservices/imap/imapprotocol.h
@@ -175,7 +175,11 @@ public:
     /*  Valid in non-authenticated state only    */
     void sendCapability();
     void sendStartTLS();
+#ifdef USE_ACCOUNTS_QT
+    void sendLogin(const QMailAccountConfiguration &config, const QByteArray &ssoLogin);
+#else
     void sendLogin(const QMailAccountConfiguration &config);
+#endif
 
     /* Valid in authenticated state only    */
     void sendList(const QMailFolder &reference, const QString &mailbox);
diff --git a/src/plugins/messageservices/imap/imapservice.cpp b/src/plugins/messageservices/imap/imapservice.cpp
index c12a5d9e..4edae55f 100644
--- a/src/plugins/messageservices/imap/imapservice.cpp
+++ b/src/plugins/messageservices/imap/imapservice.cpp
@@ -198,6 +198,12 @@ private:
 bool ImapService::Source::retrieveFolderList(const QMailAccountId &accountId, const QMailFolderId &folderId, bool descending)
 {
     Q_ASSERT(!_unavailable);
+    // Make sure service is still available, for e.g
+    // long sync operation is ongoing and account
+    // is disabled in the meantime.
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -271,6 +277,9 @@ bool ImapService::Source::retrieveNewMessages(const QMailAccountId &accountId, c
 bool ImapService::Source::retrieveMessageLists(const QMailAccountId &accountId, const QMailFolderIdList &_folderIds, uint minimum, const QMailMessageSortKey &sort, bool accountCheck)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -314,6 +323,9 @@ bool ImapService::Source::retrieveMessageLists(const QMailAccountId &accountId,
 bool ImapService::Source::retrieveMessages(const QMailMessageIdList &messageIds, QMailRetrievalAction::RetrievalSpecification spec)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -362,6 +374,9 @@ bool ImapService::Source::retrieveMessages(const QMailMessageIdList &messageIds,
 bool ImapService::Source::retrieveMessagePart(const QMailMessagePart::Location &partLocation)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -399,6 +414,9 @@ bool ImapService::Source::retrieveMessagePart(const QMailMessagePart::Location &
 bool ImapService::Source::retrieveMessageRange(const QMailMessageId &messageId, uint minimum)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -440,6 +458,9 @@ bool ImapService::Source::retrieveMessageRange(const QMailMessageId &messageId,
 bool ImapService::Source::retrieveMessagePartRange(const QMailMessagePart::Location &partLocation, uint minimum)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -482,6 +503,9 @@ bool ImapService::Source::retrieveMessagePartRange(const QMailMessagePart::Locat
 bool ImapService::Source::retrieveAll(const QMailAccountId &accountId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -534,6 +558,9 @@ void ImapService::Source::queueDisconnectedOperations(const QMailAccountId &acco
 bool ImapService::Source::exportUpdates(const QMailAccountId &accountId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -583,6 +610,8 @@ bool ImapService::Source::synchronize(const QMailAccountId &accountId)
 bool ImapService::Source::deleteMessages(const QMailMessageIdList &allIds)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
     // If a server crash has occurred duplicate messages may exist in the store.
     // A duplicate message is one that refers to the same serverUid as another message in the same account & folder.
     // Ensure that when a duplicate message is deleted no message is deleted from the server.
@@ -642,6 +671,9 @@ bool ImapService::Source::deleteMessages(const QMailMessageIdList &allIds)
 bool ImapService::Source::doDelete(const QMailMessageIdList &ids)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -667,6 +699,9 @@ bool ImapService::Source::doDelete(const QMailMessageIdList &ids)
 bool ImapService::Source::copyMessages(const QMailMessageIdList &messageIds, const QMailFolderId &destinationId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -698,6 +733,9 @@ bool ImapService::Source::copyMessages(const QMailMessageIdList &messageIds, con
 bool ImapService::Source::moveMessages(const QMailMessageIdList &messageIds, const QMailFolderId &destinationId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -764,6 +802,9 @@ bool ImapService::Source::moveMessages(const QMailMessageIdList &messageIds, con
 bool ImapService::Source::flagMessages(const QMailMessageIdList &messageIds, quint64 setMask, quint64 unsetMask)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -959,6 +1000,9 @@ bool ImapService::Source::flagMessages(const QMailMessageIdList &messageIds, qui
 bool ImapService::Source::createFolder(const QString &name, const QMailAccountId &accountId, const QMailFolderId &parentId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1046,6 +1090,9 @@ bool ImapService::Source::createStandardFolders(const QMailAccountId &accountId)
 bool ImapService::Source::deleteFolder(const QMailFolderId &folderId)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1071,6 +1118,9 @@ bool ImapService::Source::deleteFolder(const QMailFolderId &folderId)
 bool ImapService::Source::renameFolder(const QMailFolderId &folderId, const QString &name)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1143,6 +1193,8 @@ bool ImapService::Source::countMessages(const QMailMessageKey &searchCriteria, c
 bool ImapService::Source::searchMessages(const QMailMessageKey &searchCriteria, const QString &bodyText, quint64 limit, const QMailMessageSortKey &sort, bool count)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1163,6 +1215,9 @@ bool ImapService::Source::searchMessages(const QMailMessageKey &searchCriteria,
 
 bool ImapService::Source::cancelSearch()
 {
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1178,6 +1233,9 @@ bool ImapService::Source::cancelSearch()
 bool ImapService::Source::prepareMessages(const QList<QPair<QMailMessagePart::Location, QMailMessagePart::Location> > &messageIds)
 {
     Q_ASSERT(!_unavailable);
+    if (!_service)
+        return false;
+
     if (!_service->_client) {
         _service->errorOccurred(QMailServiceAction::Status::ErrFrameworkFault, tr("Account disabled"));
         return false;
@@ -1272,6 +1330,9 @@ bool ImapService::Source::initiateStrategy()
 // Copy or Move Completed
 void ImapService::Source::messageCopyCompleted(QMailMessage &message, const QMailMessage &original)
 {
+    if (!_service)
+        return;
+
     if (_service->_client->strategy()->error()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("Destination message failed to match source message"));
         return;
@@ -1582,6 +1643,11 @@ void ImapService::accountsUpdated(const QMailAccountIdList &ids)
 
 ImapService::~ImapService()
 {
+#ifdef USE_ACCOUNTS_QT
+    //If account was deleted, we should remove appropriate signon identity from the signon.db
+    if (!_accountId.isValid())
+        _client->removeSsoIdentity(_accountId);
+#endif
     disable();
     destroyIdleSession();
     delete _source;
diff --git a/src/plugins/messageservices/pop/pop.pro b/src/plugins/messageservices/pop/pop.pro
index edcc1220..bdef288d 100644
--- a/src/plugins/messageservices/pop/pop.pro
+++ b/src/plugins/messageservices/pop/pop.pro
@@ -6,6 +6,13 @@ load(qt_plugin)
 
 QT = core core5compat network qmfclient qmfclient-private qmfmessageserver
 
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
+
 HEADERS += popclient.h \
            popconfiguration.h \
            popservice.h \
diff --git a/src/plugins/messageservices/pop/popauthenticator.cpp b/src/plugins/messageservices/pop/popauthenticator.cpp
index 34b9c422..87fa0791 100644
--- a/src/plugins/messageservices/pop/popauthenticator.cpp
+++ b/src/plugins/messageservices/pop/popauthenticator.cpp
@@ -38,6 +38,7 @@
 #include <qmailauthenticator.h>
 #include <qmailtransport.h>
 
+#include <qmaillog.h>
 
 bool PopAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
@@ -68,6 +69,39 @@ bool PopAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceCon
 #endif
 }
 
+#ifdef USE_ACCOUNTS_QT
+QList<QByteArray> PopAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QList<QByteArray> &ssoLogin)
+{
+    QList<QByteArray> result;
+
+    QByteArray auth(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!auth.isEmpty()) {
+        result.append(QByteArray("AUTH ") + auth);
+    } else {
+        // If not handled by the authenticator, fall back to user/pass
+        PopConfiguration popCfg(svcCfg);
+        if(ssoLogin.isEmpty()){
+            qMailLog(POP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< popCfg.id()
+                           << ", using password from accounts configuration";
+        } else {
+            return ssoLogin;
+        }
+        result.append(QByteArray("USER ") + popCfg.mailUserName().toLatin1());
+        result.append(QByteArray("PASS ") + popCfg.mailPassword().toLatin1());
+    }
+
+    return result;
+}
+QByteArray PopAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, const QList<QByteArray> &ssoLogin)
+{
+    if (ssoLogin.size()) {
+        QByteArray pass = ssoLogin.at(0);
+        return QMailAuthenticator::getResponse(svcCfg, challenge, QString::fromLatin1(pass.constData()));
+    } else {
+        return QByteArray();
+    }
+}
+#else
 QList<QByteArray> PopAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
     QList<QByteArray> result;
@@ -90,4 +124,5 @@ QByteArray PopAuthenticator::getResponse(const QMailAccountConfiguration::Servic
 {
     return QMailAuthenticator::getResponse(svcCfg, challenge);
 }
+#endif
 
diff --git a/src/plugins/messageservices/pop/popauthenticator.h b/src/plugins/messageservices/pop/popauthenticator.h
index a704ab57..2d1a1040 100644
--- a/src/plugins/messageservices/pop/popauthenticator.h
+++ b/src/plugins/messageservices/pop/popauthenticator.h
@@ -43,8 +43,13 @@ class PopAuthenticator
 {
 public:
     static bool useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+#ifdef USE_ACCOUNTS_QT
+    static QList<QByteArray> getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, const QList<QByteArray> &ssoLogin);
+    static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, const QList<QByteArray> &ssoLogin);
+#else
     static QList<QByteArray> getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/pop/popclient.cpp b/src/plugins/messageservices/pop/popclient.cpp
index a092ca9c..8aa9cc36 100644
--- a/src/plugins/messageservices/pop/popclient.cpp
+++ b/src/plugins/messageservices/pop/popclient.cpp
@@ -77,10 +77,18 @@ PopClient::PopClient(QObject* parent)
       transport(0),
       testing(false),
       pendingDeletes(false)
+#ifdef USE_ACCOUNTS_QT
+    , ssoSessionManager(0),
+      loginFailed(false),
+      sendLogin(false)
+#endif
 {
     inactiveTimer.setSingleShot(true);
     connect(&inactiveTimer, SIGNAL(timeout()), this, SLOT(connectionInactive()));
     connect(QMailMessageBuffer::instance(), SIGNAL(flushed()), this, SLOT(messageBufferFlushed()));
+#ifdef USE_ACCOUNTS_QT
+    connect(QMailStore::instance(), SIGNAL(accountsUpdated(QMailAccountIdList)), this, SLOT(onAccountsUpdated(QMailAccountIdList)));
+#endif
 }
 
 PopClient::~PopClient()
@@ -91,6 +99,10 @@ PopClient::~PopClient()
 
     delete dataStream;
     delete transport;
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager)
+        ssoSessionManager->deleteSsoIdentity();
+#endif
 }
 
 void PopClient::messageBufferFlushed()
@@ -169,6 +181,7 @@ void PopClient::newConnection()
     testing = false;
     pendingDeletes = false;
     lastStatusTimer.start();
+
     if (transport && transport->connected()) {
         if (selected) {
             // Re-use the existing connection
@@ -258,6 +271,24 @@ void PopClient::setAccount(const QMailAccountId &id)
             qMailLog(POP) <<  "Flags for POP folder" << folder.id() << folder.path() << "updated";
         }
     }
+
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoSessionManager) {
+        PopConfiguration popCfg(config);
+        ssoSessionManager = new SSOSessionManager(this);
+        if (ssoSessionManager->createSsoIdentity(id, "pop3", popCfg.mailEncryption())) {
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionResponse(QList<QByteArray>))
+                            ,this, SLOT(onSsoSessionResponse(QList<QByteArray>))));
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionError(QString)),this, SLOT(onSsoSessionError(QString))));
+            qMailLog(POP) << Q_FUNC_INFO << "SSO identity is found for account id: "<< id;
+        } else {
+            delete ssoSessionManager;
+            ssoSessionManager = 0;
+            qMailLog(POP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                          << ", accounts configuration will be used";
+        }
+    }
+#endif
 }
 
 QMailAccountId PopClient::accountId() const
@@ -530,12 +561,30 @@ void PopClient::processResponse(const QString &response)
     {
         if (response[0] != '+') {
             // Authentication failed
+#ifdef USE_ACCOUNTS_QT
+            if (ssoSessionManager && ssoSessionManager->checkingCredentials()) {
+                operationFailed(QMailServiceAction::Status::ErrLoginFailed, "");
+            } else {
+                if (ssoSessionManager && !loginFailed) {
+                    loginFailed = true;
+                    ssoProcessLogin();
+                } else {
+                    ssoCredentialsNeedUpdate();
+                    operationFailed(QMailServiceAction::Status::ErrLoginFailed, "");
+                }
+            }
+#else
             operationFailed(QMailServiceAction::Status::ErrLoginFailed, "");
+#endif
         } else {
             if ((response.length() > 2) && (response[1] == ' ')) {
                 // This is a continuation containing a challenge string (in Base64)
                 QByteArray challenge = QByteArray::fromBase64(response.mid(2).toLatin1());
+#ifdef USE_ACCOUNTS_QT
+                QByteArray response(PopAuthenticator::getResponse(config.serviceConfiguration("pop3"), challenge, ssoLogin));
+#else
                 QByteArray response(PopAuthenticator::getResponse(config.serviceConfiguration("pop3"), challenge));
+#endif
 
                 if (!response.isEmpty()) {
                     // Send the response as Base64 encoded
@@ -744,7 +793,11 @@ void PopClient::nextAction()
         emit updateStatus(tr("Logging in"));
 
         // Get the login command sequence to use
+#ifdef USE_ACCOUNTS_QT
+        authCommands = PopAuthenticator::getAuthentication(config.serviceConfiguration("pop3"), capabilities, ssoLogin);
+#else
         authCommands = PopAuthenticator::getAuthentication(config.serviceConfiguration("pop3"), capabilities);
+#endif
 
         nextStatus = Auth;
         nextCommand = authCommands.takeFirst();
@@ -1241,6 +1294,11 @@ void PopClient::checkForNewMessages()
 void PopClient::cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text)
 {
     operationFailed(code, text);
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager) {
+        ssoSessionManager->cancel();
+    }
+#endif
 }
 
 void PopClient::retrieveOperationCompleted()
@@ -1338,3 +1396,72 @@ void PopClient::removeAllFromBuffer(QMailMessage *message)
         _bufferedMessages.remove(i);
     }
 }
+
+#ifdef USE_ACCOUNTS_QT
+void PopClient::removeSsoIdentity(const QMailAccountId &accountId)
+{
+    if (config.id() == accountId) {
+        if (ssoSessionManager) {
+            ssoSessionManager->removeSsoIdentity();
+            delete ssoSessionManager;
+            ssoSessionManager = 0;
+        }
+    }
+}
+
+void PopClient::onSsoSessionResponse(const QList<QByteArray> &ssoCredentials)
+{
+    qMailLog(POP)  << "Got SSO response";
+    if(!ssoCredentials.isEmpty()) {
+        ssoLogin = ssoCredentials;
+        if (sendLogin) {
+            sendLogin = false;
+            newConnection();
+        }
+    }
+}
+
+void PopClient::onSsoSessionError(const QString &error)
+{
+    loginFailed = false;
+    sendLogin = false;
+    qMailLog(POP) <<  "Got SSO error:" << error;
+    operationFailed(QMailSearchAction::Status::ErrLoginFailed, error);
+}
+
+void PopClient::ssoCredentialsNeedUpdate()
+{
+    if (ssoSessionManager) {
+        ssoSessionManager->credentialsNeedUpdate();
+    } else {
+        qMailLog(POP) << Q_FUNC_INFO << "SSO Error: can't set credentials need update.";
+    }
+}
+
+void PopClient::ssoProcessLogin()
+{
+    if (loginFailed) {
+        if (ssoSessionManager) {
+            sendLogin = true;
+            ssoSessionManager->recreateSsoIdentity();
+        } else
+            operationFailed(QMailServiceAction::Status::ErrLoginFailed, "SSO Error: can't recreate identity.");
+    } else {
+        status = Connected;
+        nextAction();
+    }
+}
+
+void PopClient::onAccountsUpdated(const QMailAccountIdList &list)
+{
+    if (!list.contains(accountId()))
+        return;
+
+    QMailAccount acc(accountId());
+    bool isEnabled(acc.status() & QMailAccount::Enabled);
+    if (!isEnabled)
+        return;
+    setAccount(accountId());
+}
+
+#endif
diff --git a/src/plugins/messageservices/pop/popclient.h b/src/plugins/messageservices/pop/popclient.h
index 41f7026a..96277bbe 100644
--- a/src/plugins/messageservices/pop/popclient.h
+++ b/src/plugins/messageservices/pop/popclient.h
@@ -47,6 +47,10 @@
 #include <qmailtransport.h>
 #include <qmailmessagebuffer.h>
 
+#ifdef USE_ACCOUNTS_QT
+#include <ssosessionmanager.h>
+#endif
+
 class LongStream;
 class QMailTransport;
 class QMailAccount;
@@ -83,6 +87,10 @@ public:
     void messageFlushed(QMailMessage &message, bool isComplete);
     void removeAllFromBuffer(QMailMessage *message);
 
+#ifdef USE_ACCOUNTS_QT
+    void removeSsoIdentity(const QMailAccountId &accountId);
+#endif
+
 signals:
     void connectionError(QMailServiceAction::Status::ErrorCode status, const QString &msg);
     void errorOccurred(int, const QString &);
@@ -101,10 +109,20 @@ protected slots:
     void connected(QMailTransport::EncryptType encryptType);
     void transportError(int, QString msg);
 
+#ifdef USE_ACCOUNTS_QT
+    void onAccountsUpdated(const QMailAccountIdList& list);
+    void onSsoSessionError(const QString &error);
+    void onSsoSessionResponse(const QList<QByteArray> &ssoCredentials);
+#endif
+
     void connectionInactive();
     void incomingData();
 
 private:
+#ifdef USE_ACCOUNTS_QT
+    void ssoCredentialsNeedUpdate();
+    void ssoProcessLogin();
+#endif
     void deactivateConnection();
     int nextMsgServerPos();
     int msgPosFromUidl(QString uidl);
@@ -183,6 +201,13 @@ private:
     QVector<QMailMessageBufferFlushCallback*> callbacks;
     bool testing;
     bool pendingDeletes;
+
+#ifdef USE_ACCOUNTS_QT
+    SSOSessionManager* ssoSessionManager;
+    bool loginFailed;
+    bool sendLogin;
+    QList<QByteArray> ssoLogin;
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/pop/popservice.cpp b/src/plugins/messageservices/pop/popservice.cpp
index 7d9aa16e..3b8663a7 100644
--- a/src/plugins/messageservices/pop/popservice.cpp
+++ b/src/plugins/messageservices/pop/popservice.cpp
@@ -101,6 +101,9 @@ private:
 
 bool PopService::Source::retrieveFolderList(const QMailAccountId &accountId, const QMailFolderId &folderId, bool descending)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -123,6 +126,8 @@ bool PopService::Source::retrieveFolderList(const QMailAccountId &accountId, con
 
 bool PopService::Source::retrieveMessageLists(const QMailAccountId &accountId, const QMailFolderIdList &folderIds, uint minimum, const QMailMessageSortKey &sort)
 {
+    if (!_service)
+        return false;
     if (folderIds.isEmpty()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No folders specified"));
         return false;
@@ -133,6 +138,9 @@ bool PopService::Source::retrieveMessageLists(const QMailAccountId &accountId, c
 
 bool PopService::Source::retrieveMessageList(const QMailAccountId &accountId, const QMailFolderId &folderId, uint minimum, const QMailMessageSortKey &sort)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -163,6 +171,9 @@ bool PopService::Source::retrieveMessageList(const QMailAccountId &accountId, co
 
 bool PopService::Source::retrieveMessages(const QMailMessageIdList &messageIds, QMailRetrievalAction::RetrievalSpecification spec)
 {
+    if (!_service)
+        return false;
+
     if (messageIds.isEmpty()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No messages to retrieve"));
         return false;
@@ -189,6 +200,9 @@ bool PopService::Source::retrieveMessages(const QMailMessageIdList &messageIds,
 
 bool PopService::Source::retrieveAll(const QMailAccountId &accountId)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -202,6 +216,9 @@ bool PopService::Source::retrieveAll(const QMailAccountId &accountId)
 
 bool PopService::Source::exportUpdates(const QMailAccountId &accountId)
 {
+    if (!_service)
+        return false;
+
     if (!accountId.isValid()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
         return false;
@@ -219,6 +236,9 @@ bool PopService::Source::synchronize(const QMailAccountId &accountId)
 
 bool PopService::Source::deleteMessages(const QMailMessageIdList &messageIds)
 {
+    if (!_service)
+        return false;
+
     if (messageIds.isEmpty()) {
         _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No messages to delete"));
         return false;
@@ -324,6 +344,11 @@ PopService::PopService(const QMailAccountId &accountId)
 
 PopService::~PopService()
 {
+#ifdef USE_ACCOUNTS_QT
+    //If account was deleted, we should remove appropriate signon identity from the signon.db
+    if (!accountId().isValid())
+        _client.removeSsoIdentity(accountId());
+#endif
     delete _source;
 }
 
diff --git a/src/plugins/messageservices/smtp/smtp.pro b/src/plugins/messageservices/smtp/smtp.pro
index a987d84a..62f60541 100644
--- a/src/plugins/messageservices/smtp/smtp.pro
+++ b/src/plugins/messageservices/smtp/smtp.pro
@@ -6,6 +6,13 @@ load(qt_plugin)
 
 QT = core core5compat network qmfclient qmfmessageserver
 
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
+
 HEADERS += smtpauthenticator.h \
            smtpclient.h \
            smtpconfiguration.h \
diff --git a/src/plugins/messageservices/smtp/smtpauthenticator.cpp b/src/plugins/messageservices/smtp/smtpauthenticator.cpp
index 76fb904e..0dae24c5 100644
--- a/src/plugins/messageservices/smtp/smtpauthenticator.cpp
+++ b/src/plugins/messageservices/smtp/smtpauthenticator.cpp
@@ -37,6 +37,7 @@
 
 #include <qmailauthenticator.h>
 
+#include <qmaillog.h>
 
 namespace {
 
@@ -44,6 +45,67 @@ QMap<QMailAccountId, QList<QByteArray> > gResponses;
 
 }
 
+#ifdef USE_ACCOUNTS_QT
+QByteArray SmtpAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, QList<QByteArray> &ssoLogin)
+{
+    QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!result.isEmpty())
+        return result.prepend("AUTH ");
+
+#ifndef QT_NO_SSL
+    SmtpConfiguration smtpCfg(svcCfg);
+    if (smtpCfg.smtpAuthentication() != SmtpConfiguration::Auth_NONE) {
+        QMailAccountId id(smtpCfg.id());
+        QByteArray username(smtpCfg.smtpUsername().toUtf8());
+        QByteArray pass;
+        if (ssoLogin.isEmpty()) {
+            pass = smtpCfg.smtpPassword().toUtf8();
+            qMailLog(SMTP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                           << ", using password from accounts configuration";
+        } else {
+            QList<QByteArray> responses = ssoLogin;
+            QByteArray res = responses.takeFirst();
+            gResponses[id] = responses;
+            return res;
+        }
+
+        if (smtpCfg.smtpAuthentication() == SmtpConfiguration::Auth_LOGIN) {
+            result = QByteArray("LOGIN");
+            gResponses[id] = (QList<QByteArray>() << username << pass);
+        } else if (smtpCfg.smtpAuthentication() == SmtpConfiguration::Auth_PLAIN) {
+            result = QByteArray("PLAIN ") + QByteArray(username + '\0' + username + '\0' + pass).toBase64();
+            gResponses[id] = (QList<QByteArray>() << QByteArray(username + '\0' + username + '\0' + pass));
+        }
+    }
+#endif
+
+    if (!result.isEmpty()) {
+        result.prepend("AUTH ");
+    }
+    return result;
+}
+
+QByteArray SmtpAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, QList<QByteArray> &ssoLogin)
+{
+    QByteArray result;
+
+    QMap<QMailAccountId, QList<QByteArray> >::iterator it = gResponses.find(svcCfg.id());
+    if (it != gResponses.end()) {
+        QList<QByteArray> &responses = it.value();
+        result = responses.takeFirst();
+
+        if (responses.isEmpty())
+            gResponses.erase(it);
+    } else {
+        if (ssoLogin.size()) {
+            QByteArray pass = ssoLogin.at(0);
+            result = QMailAuthenticator::getResponse(svcCfg, challenge, QString::fromLatin1(pass.constData()));
+        }
+    }
+
+    return result;
+}
+#else
 QByteArray SmtpAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
 {
     QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
@@ -90,4 +152,4 @@ QByteArray SmtpAuthenticator::getResponse(const QMailAccountConfiguration::Servi
 
     return result;
 }
-
+#endif
diff --git a/src/plugins/messageservices/smtp/smtpauthenticator.h b/src/plugins/messageservices/smtp/smtpauthenticator.h
index 97300b99..06183262 100644
--- a/src/plugins/messageservices/smtp/smtpauthenticator.h
+++ b/src/plugins/messageservices/smtp/smtpauthenticator.h
@@ -42,8 +42,13 @@
 class SmtpAuthenticator
 {
 public:
+#ifdef USE_ACCOUNTS_QT
+    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities, QList<QByteArray> &ssoLogin);
+    static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge, QList<QByteArray> &ssoLogin);
+#else
     static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
     static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/smtp/smtpclient.cpp b/src/plugins/messageservices/smtp/smtpclient.cpp
index 71785ea0..5add3c1f 100644
--- a/src/plugins/messageservices/smtp/smtpclient.cpp
+++ b/src/plugins/messageservices/smtp/smtpclient.cpp
@@ -111,6 +111,11 @@ SmtpClient::SmtpClient(QObject* parent)
     , waitingForBytes(0)
     , notUsingAuth(false)
     , authTimeout(0)
+#ifdef USE_ACCOUNTS_QT
+    , ssoSessionManager(0)
+    , loginFailed(false)
+    , sendLogin(false)
+#endif
 {
     connect(QMailStore::instance(), SIGNAL(accountsUpdated(const QMailAccountIdList&)), 
             this, SLOT(accountsUpdated(const QMailAccountIdList&)));
@@ -121,6 +126,10 @@ SmtpClient::~SmtpClient()
     delete transport;
     delete temporaryFile;
     delete authTimeout;
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager)
+        ssoSessionManager->deleteSsoIdentity();
+#endif
 }
 
 void SmtpClient::accountsUpdated(const QMailAccountIdList &ids)
@@ -144,6 +153,23 @@ void SmtpClient::setAccount(const QMailAccountId &id)
 {
     // Load the current configuration for this account
     config = QMailAccountConfiguration(id);
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoSessionManager) {
+        SmtpConfiguration smtpCfg(config);
+        ssoSessionManager = new SSOSessionManager(this);
+        if (ssoSessionManager->createSsoIdentity(id, "smtp", smtpCfg.smtpAuthentication())) {
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionResponse(QList<QByteArray>))
+                            ,this, SLOT(onSsoSessionResponse(QList<QByteArray>))));
+            ENFORCE(connect(ssoSessionManager, SIGNAL(ssoSessionError(QString)),this, SLOT(onSsoSessionError(QString))));
+            qMailLog(SMTP) << Q_FUNC_INFO << "SSO identity is found for account id: "<< id;
+        } else {
+            delete ssoSessionManager;
+            ssoSessionManager = 0;
+            qMailLog(SMTP) << Q_FUNC_INFO << "SSO identity is not found for account id: "<< id
+                           << ", accounts configuration will be used";
+        }
+    }
+#endif
 }
 
 QMailAccountId SmtpClient::account() const
@@ -154,6 +180,9 @@ QMailAccountId SmtpClient::account() const
 void SmtpClient::newConnection()
 {
     qMailLog(SMTP) << "newConnection";
+#ifdef USE_ACCOUNTS_QT
+    loginFailed = false;
+#endif
     if (sending) {
         operationFailed(QMailServiceAction::Status::ErrConnectionInUse, tr("Cannot send message; transport in use"));
         return;
@@ -165,6 +194,12 @@ void SmtpClient::newConnection()
         return;
     }
 
+    // Load the current configuration for this account
+    // Reload the account configuration whenever a new SMTP
+    // connection is created, in order to ensure the changes
+    // in the account settings are being managed properly.
+    config = QMailAccountConfiguration(config.id());
+
     SmtpConfiguration smtpCfg(config);
     if ( smtpCfg.smtpServer().isEmpty() ) {
         status = Done;
@@ -549,6 +584,31 @@ void SmtpClient::nextAction(const QString &response)
         addressComponent = localAddress.toIPv4Address();
 
         // Find the authentication mode to use
+#ifdef USE_ACCOUNTS_QT
+        if (ssoSessionManager) {
+            // start single signon session
+            status = SignOnSession;
+            nextAction(QString());
+        } else {
+            // Use credentials from accounts db
+            // Find the authentication mode to use
+            ssoLogin.clear();
+            QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities, ssoLogin));
+            if (!authCmd.isEmpty()) {
+                sendCommand(authCmd);
+                status = Authenticating;
+            } else {
+                foreach (QString const& capability, capabilities) {
+                    if (capability.startsWith("AUTH", Qt::CaseInsensitive)) {
+                        notUsingAuth = true;
+                        break;
+                    }
+                }
+                status = Authenticated;
+                nextAction(QString());
+            }
+        }
+#else
         QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities));
         if (!authCmd.isEmpty()) {
             sendCommand(authCmd);
@@ -563,14 +623,50 @@ void SmtpClient::nextAction(const QString &response)
             status = Authenticated;
             nextAction(QString());
         }
+#endif
         break;
     }
+#ifdef USE_ACCOUNTS_QT
+    case SignOnSession:
+    {
+        if (loginFailed) {
+            if (ssoSessionManager && ssoSessionManager->checkingCredentials()) {
+                operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+            } else {
+                if (ssoSessionManager) {
+                    sendLogin = true;
+                    ssoSessionManager->recreateSsoIdentity();
+                } else {
+                    operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+                }
+            }
+        } else {
+            if (!ssoSessionManager->waitForSso()) {
+                QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities, ssoLogin));
+                if (!authCmd.isEmpty()) {
+                    sendCommand(authCmd);
+                    status = Authenticating;
+                } else {
+                    status = Authenticated;
+                    nextAction(QString());
+                }
+            } else {
+                sendLogin = true;
+            }
+        }
+        break;
+    }
+#endif
     case Authenticating:
     {
         if (responseCode == 334) {
             // This is a continuation containing a challenge string (in Base64)
             QByteArray challenge = QByteArray::fromBase64(response.mid(4).toLatin1());
+#ifdef USE_ACCOUNTS_QT
+            QByteArray response(SmtpAuthenticator::getResponse(config.serviceConfiguration("smtp"), challenge, ssoLogin));
+#else
             QByteArray response(SmtpAuthenticator::getResponse(config.serviceConfiguration("smtp"), challenge));
+#endif
 
             if (!response.isEmpty()) {
                 // Send the response as Base64 encoded, mask the debug output
@@ -578,8 +674,9 @@ void SmtpClient::nextAction(const QString &response)
                 bufferedResponse.clear();
                 return;
             } else {
-                // No username/password defined
-                operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+                // Challenge response is empty
+                // send a empty response.
+                sendCommand("");
             }
         } else if (responseCode == 235) {
             // We are now authenticated
@@ -588,14 +685,29 @@ void SmtpClient::nextAction(const QString &response)
         } else if (responseCode == 530) {
             operationFailed(QMailServiceAction::Status::ErrConfiguration, response);
         } else {
+#ifdef USE_ACCOUNTS_QT
+            if (ssoSessionManager && ssoSessionManager->checkingCredentials()) {
+               operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+            } else if (!loginFailed) {
+                loginFailed = true;
+                status = SignOnSession;
+                nextAction(QString());
+            } else {
+                ssoCredentialsNeedUpdate();
+                operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+            }
+#else
             operationFailed(QMailServiceAction::Status::ErrLoginFailed, response);
+#endif
         }
-
         // Otherwise, we're authenticated
         break;
     }
     case Authenticated:
     {
+#ifdef USE_ACCOUNTS_QT
+        loginFailed = false;
+#endif
         if (mailItr == mailList.end()) {
             // Nothing to send
             status = Quit;
@@ -849,6 +961,10 @@ void SmtpClient::nextAction(const QString &response)
 void SmtpClient::cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text)
 {
     operationFailed(code, text);
+#ifdef USE_ACCOUNTS_QT
+    if (ssoSessionManager)
+        ssoSessionManager->cancel();
+#endif
 }
 
 void SmtpClient::messageProcessed(const QMailMessageId &id)
@@ -1003,3 +1119,53 @@ void SmtpClient::stopTransferring()
         status = Sent;
     }
 }
+
+#ifdef USE_ACCOUNTS_QT
+void SmtpClient::ssoCredentialsNeedUpdate()
+{
+    if (ssoSessionManager) {
+        ssoSessionManager->credentialsNeedUpdate();
+    } else {
+        qMailLog(SMTP) << Q_FUNC_INFO << "SSO Error: can't set credentials need update.";
+    }
+}
+
+void SmtpClient::removeSsoIdentity(const QMailAccountId &accountId)
+{
+    if (config.id() == accountId) {
+        if (ssoSessionManager) {
+            ssoSessionManager->removeSsoIdentity();
+            delete ssoSessionManager;
+            ssoSessionManager = 0;
+        }
+    }
+}
+
+void SmtpClient::onSsoSessionResponse(const QList<QByteArray> &ssoCredentials)
+{
+    qMailLog(SMTP)  << "Got SSO response";
+    if(!ssoCredentials.isEmpty()) {
+        ssoLogin = ssoCredentials;
+        if (sendLogin) {
+            sendLogin = false;
+            QByteArray authCmd(SmtpAuthenticator::getAuthentication(config.serviceConfiguration("smtp"), capabilities, ssoLogin));
+            if (!authCmd.isEmpty()) {
+                sendCommand(authCmd);
+                status = Authenticating;
+            } else {
+                status = Authenticated;
+                nextAction(QString());
+            }
+        }
+    }
+}
+
+void SmtpClient::onSsoSessionError(const QString &error)
+{
+    // Reset vars
+    loginFailed = false;
+    sendLogin = false;
+    qMailLog(SMTP) <<  "Got SSO error:" << error;
+    operationFailed(QMailServiceAction::Status::ErrLoginFailed, error);
+}
+#endif
diff --git a/src/plugins/messageservices/smtp/smtpclient.h b/src/plugins/messageservices/smtp/smtpclient.h
index a077273a..3d2e6ecc 100644
--- a/src/plugins/messageservices/smtp/smtpclient.h
+++ b/src/plugins/messageservices/smtp/smtpclient.h
@@ -44,6 +44,10 @@
 #include <qmailmessageserver.h>
 #include <qmailtransport.h>
 
+#ifdef USE_ACCOUNTS_QT
+#include <ssosessionmanager.h>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QTemporaryFile;
@@ -70,6 +74,11 @@ public:
     void setAccount(const QMailAccountId &accountId);
     QMailAccountId account() const;
 
+#ifdef USE_ACCOUNTS_QT
+    void ssoCredentialsNeedUpdate();
+    void removeSsoIdentity(const QMailAccountId &accountId);
+#endif
+
     void newConnection();
     void cancelTransfer(QMailServiceAction::Status::ErrorCode code, const QString &text);
 
@@ -95,6 +104,10 @@ protected slots:
 private slots:
     void sendMoreData(qint64);
     void authExpired();
+#ifdef USE_ACCOUNTS_QT
+    void onSsoSessionResponse(const QList<QByteArray> &ssoCredentials);
+    void onSsoSessionError(const QString &error);
+#endif
 
 private:
     void sendCommand(const char *data, int len = -1, bool maskDebug = false);
@@ -111,11 +124,19 @@ private:
     void stopTransferring();
 
 private:
+#ifdef USE_ACCOUNTS_QT
+    enum TransferStatus
+    {
+        Init, Helo, Extension, StartTLS, TLS, Connected, SignOnSession,  Authenticating, Authenticated,
+        MetaData, From, Recv, MRcv, PrepareData, Data, Body, Chunk, ChunkSent, Sent, Quit, Done
+    };
+#else
     enum TransferStatus
     {
         Init, Helo, Extension, StartTLS, TLS, Connected, Authenticating, Authenticated,
         MetaData, From, Recv, MRcv, PrepareData, Data, Body, Chunk, ChunkSent, Sent, Quit, Done
     };
+#endif
 
     QMailAccountConfiguration config;
     TransferStatus status;
@@ -149,6 +170,13 @@ private:
     bool notUsingAuth;
 
     QTimer *authTimeout;
+
+#ifdef USE_ACCOUNTS_QT
+    SSOSessionManager* ssoSessionManager;
+    bool loginFailed;
+    bool sendLogin;
+    QList<QByteArray> ssoLogin;
+#endif
 };
 
 #endif
diff --git a/src/plugins/messageservices/smtp/smtpservice.cpp b/src/plugins/messageservices/smtp/smtpservice.cpp
index e098fbc8..8c7ab73f 100644
--- a/src/plugins/messageservices/smtp/smtpservice.cpp
+++ b/src/plugins/messageservices/smtp/smtpservice.cpp
@@ -127,7 +127,10 @@ SmtpService::SmtpService(const QMailAccountId &accountId)
 
     _client.setAccount(accountId);
 
+// Don't try to autoconnect on account creation for SSO services
+#ifndef USE_ACCOUNTS_QT
     fetchCapabilities();
+#endif
 }
 
 void SmtpService::fetchCapabilities()
@@ -255,6 +258,11 @@ void SmtpService::onAccountsUpdated(const QMailAccountIdList &accountIds)
 
 SmtpService::~SmtpService()
 {
+#ifdef USE_ACCOUNTS_QT
+    //If account was deleted, we should remove appropriate signon identity from the signon.db
+    if (!accountId().isValid())
+        _client.removeSsoIdentity(accountId());
+#endif
     delete _sink;
 }
 
diff --git a/src/plugins/plugins.pro b/src/plugins/plugins.pro
index dc1528b7..5226faa1 100644
--- a/src/plugins/plugins.pro
+++ b/src/plugins/plugins.pro
@@ -11,3 +11,6 @@ exists(/usr/bin/gpgme-config) {
     SUBDIRS += crypto/smime
 }
 
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    SUBDIRS += ssoauth/password
+}
diff --git a/src/plugins/ssoauth/password/password.pro b/src/plugins/ssoauth/password/password.pro
new file mode 100644
index 00000000..f41e80ad
--- /dev/null
+++ b/src/plugins/ssoauth/password/password.pro
@@ -0,0 +1,21 @@
+TEMPLATE = lib 
+TARGET = passwordplugin
+QT = core qmfclient qmfclient-private
+PLUGIN_TYPE = ssoauth
+load(qt_plugin)
+
+CONFIG -= create_cmake
+
+DEPENDPATH += .
+
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    QT += xml
+    PKGCONFIG += accounts-qt5
+    PKGCONFIG += libsignon-qt5
+}
+
+HEADERS += passwordplugin.h
+
+SOURCES += passwordplugin.cpp
+
diff --git a/src/plugins/ssoauth/password/passwordplugin.cpp b/src/plugins/ssoauth/password/passwordplugin.cpp
new file mode 100644
index 00000000..4eac2d1b
--- /dev/null
+++ b/src/plugins/ssoauth/password/passwordplugin.cpp
@@ -0,0 +1,200 @@
+/****************************************************************************
+**
+** Copyright (c) 2013-2020 Jolla Ltd.
+** Copyright (c) 2020 Open Mobile Platform LLC.
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "passwordplugin.h"
+#include "qmailnamespace.h"
+
+// libaccounts-qt
+#include <Accounts/Manager>
+#include <Accounts/Account>
+
+// From Qt Messaging Framework IMAP plugin
+// Ensure a string is quoted, if required for IMAP transmission
+// As per IMAP4 rfc 2060 section 4.2
+QString quoteIMAPString(const QString& input)
+{
+    // We can't easily catch controls other than those caught by \\s...
+    QRegExp atomSpecials("[\\(\\)\\{\\s\\*%\\\\\"\\]]");
+
+    // The empty string must be quoted
+    if (input.isEmpty())
+        return QString("\"\"");
+
+    if (atomSpecials.indexIn(input) == -1)
+        return input;
+
+    // We need to quote this string because it is not an atom
+    QString result(input);
+
+    QString::iterator begin = result.begin(), it = begin;
+    while (it != result.end()) {
+        // We need to escape any characters specially treated in quotes
+        if ((*it) == '\\' || (*it) == '"') {
+            int pos = (it - begin);
+            result.insert(pos, '\\');
+            it = result.begin() + (pos + 1);
+        }
+        ++it;
+    }
+
+    return QMail::quoteString(result);
+}
+
+QByteArray quoteIMAPString(const QByteArray& input)
+{
+    return quoteIMAPString(QString::fromLatin1(input)).toLatin1();
+}
+
+SSOPasswordPlugin::SSOPasswordPlugin(QObject *parent)
+    : SSOAuthService(parent)
+    , m_accountManager(new Accounts::Manager(this))
+{
+}
+
+SSOPasswordPlugin::~SSOPasswordPlugin()
+{
+}
+
+QList<QByteArray> SSOPasswordPlugin::getIMAPAuthentication(const QString &password,
+                                                    const QString &username, int serviceAuthentication) const
+{
+    if (serviceAuthentication == QMail::PlainMechanism) {
+        QByteArray user(username.toLatin1());
+        QByteArray pass(password.toLatin1());
+        return QList<QByteArray>() << QByteArray("AUTHENTICATE PLAIN ") + QByteArray(user + '\0' + user + '\0' + pass).toBase64();
+    } if (serviceAuthentication == QMail::CramMd5Mechanism) {
+        return QList<QByteArray>() << QByteArray(password.toLatin1());
+    } else {
+        return QList<QByteArray>() << QByteArray("LOGIN") + ' ' + quoteIMAPString(username.toLatin1())
+                                   + ' ' + quoteIMAPString(password.toLatin1());
+    }
+}
+
+QList<QByteArray> SSOPasswordPlugin::getPOPAuthentication(const QString &password,
+                                                   const QString &username, int serviceAuthentication) const
+{
+    QList<QByteArray> result;
+    if (serviceAuthentication == QMail::CramMd5Mechanism) {
+        result.append(QByteArray(password.toLatin1()));
+    } else {
+        result.append(QByteArray("USER ") + username.toLatin1());
+        result.append(QByteArray("PASS ") + password.toLatin1());
+    }
+
+    return result;
+}
+
+QList<QByteArray> SSOPasswordPlugin::getSMTPAuthentication(const QString &password,
+                                                    const QString &username, int serviceAuthentication) const
+{
+    QList<QByteArray> result;
+    QByteArray user(username.toUtf8());
+    QByteArray pass(password.toUtf8());
+
+    if (serviceAuthentication == QMail::LoginMechanism) {
+        result.append(QByteArray("AUTH LOGIN"));
+        result.append(QByteArray(user));
+        result.append(QByteArray(pass));
+    } else if (serviceAuthentication == QMail::PlainMechanism) {
+        result.append(QByteArray("AUTH PLAIN ") + QByteArray(user + '\0' + user + '\0' + pass).toBase64());
+        result.append(QByteArray(user + '\0' + user + '\0' + pass));
+    } else if (serviceAuthentication == QMail::CramMd5Mechanism) {
+        result.append(QByteArray(pass));
+    }
+    return result;
+}
+
+SSOAuthService* SSOPasswordPlugin::createService()
+{
+    return this;
+}
+
+QString SSOPasswordPlugin::key() const
+{
+    return "password";
+}
+QList<QByteArray> SSOPasswordPlugin::authentication(const SignOn::SessionData &sessionData,
+                                                const QString &serviceType, const QString &userName, int serviceAuthentication) const
+{
+    QString password = sessionData.Secret();
+    QString username = sessionData.UserName();
+
+    if (username.isEmpty())
+        username = userName;
+
+    if (serviceType == "imap4") {
+        return getIMAPAuthentication(password, username, serviceAuthentication);
+    } else if (serviceType == "pop3") {
+        return getPOPAuthentication(password, username, serviceAuthentication);
+    } else if (serviceType == "smtp") {
+        return getSMTPAuthentication(password, username, serviceAuthentication);
+    } else {
+        return QList<QByteArray>();
+    }
+}
+
+void SSOPasswordPlugin::credentialsNeedUpdate(int accountId)
+{
+    // Mirrors the functionality of SSOOauth2Plugin::credentialsNeedUpdate
+    // See base-qmf-oauth2-plugin/oauth2plugin.cpp
+    Accounts::Account *account = Accounts::Account::fromId(m_accountManager, accountId, this);
+    Accounts::Service srv(m_accountManager->service(QStringLiteral("email")));
+    if (srv.isValid()) {
+        qWarning() << "password-plugin: setting CredentialsNeedUpdate on account:" << account->id();
+        account->selectService(srv);
+        account->setValue("CredentialsNeedUpdate", QVariant::fromValue<bool>(true));
+        account->setValue("CredentialsNeedUpdateFrom", QVariant::fromValue<QString>(QString::fromLatin1("messageserver5")));
+        account->selectService(Accounts::Service());
+        account->syncAndBlock();
+    }
+    account->deleteLater();
+}
+
+SignOn::SessionData SSOPasswordPlugin::sessionData(const QString &accountProvider,  QVariantMap authParameters) const
+{
+    Q_UNUSED(accountProvider);
+    Q_UNUSED(authParameters);
+
+    SignOn::SessionData data;
+    data.setUiPolicy(SignOn::NoUserInteractionPolicy);
+    return data;
+}
+
diff --git a/src/plugins/ssoauth/password/passwordplugin.h b/src/plugins/ssoauth/password/passwordplugin.h
new file mode 100644
index 00000000..8603694e
--- /dev/null
+++ b/src/plugins/ssoauth/password/passwordplugin.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (c) 2013-2020 Jolla Ltd.
+** Copyright (c) 2020 Open Mobile Platform LLC.
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef PASSWORDPLUGIN_H
+#define PASSWORDPLUGIN_H
+
+#include "ssoauthplugin.h"
+#include <QtPlugin>
+#include <QVariantMap>
+#include <SignOn/SessionData>
+
+namespace Accounts {
+    class Manager;
+    class Account;
+}
+
+class SSOPasswordPlugin : public SSOAuthService
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.SSOPasswordPluginHandlerFactoryInterface")
+
+public:
+    SSOPasswordPlugin( QObject *parent = 0 );
+    ~SSOPasswordPlugin();
+
+    virtual QString key() const;
+    virtual QList<QByteArray> authentication(const SignOn::SessionData &sessionData,
+                                         const QString &serviceType, const QString &userName, int serviceAuthentication) const;
+    virtual void credentialsNeedUpdate(int accountId);
+    virtual SignOn::SessionData sessionData(const QString &accountProvider, QVariantMap authParameters) const;
+    virtual SSOAuthService* createService();
+
+private:
+    QList<QByteArray> getIMAPAuthentication(const QString &password, const QString &username, int serviceAuthentication) const;
+    QList<QByteArray> getPOPAuthentication(const QString &password, const QString &username, int serviceAuthentication) const;
+    QList<QByteArray> getSMTPAuthentication(const QString &password, const QString &username, int serviceAuthentication) const;
+    Accounts::Manager *m_accountManager;
+};
+
+#endif // PASSWORDPLUGIN_H
diff --git a/src/tools/messageserver/servicehandler.cpp b/src/tools/messageserver/servicehandler.cpp
index 93ebace0..ca105660 100644
--- a/src/tools/messageserver/servicehandler.cpp
+++ b/src/tools/messageserver/servicehandler.cpp
@@ -801,10 +801,23 @@ void ServiceHandler::accountsAdded(const QMailAccountIdList &ids)
 
 void ServiceHandler::accountsUpdated(const QMailAccountIdList &ids)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList idList;
+    foreach (const QMailAccountId &id, ids) {
+        if (!sourceMap.contains(id) && !sinkMap.contains(id)) {
+                idList << id;
+        }
+    }
+    if (!idList.isEmpty()) {
+        registerAccountServices(idList);
+    }
+
+#else
     // Only respond to updates that were generated by other processes
     if (QMailStore::instance()->asynchronousEmission()) {
         reregisterAccountServices(ids, QMailServiceAction::Status::ErrInternalStateReset, tr("Account updated by other process"));
     }
+#endif
 }
 
 void ServiceHandler::accountsRemoved(const QMailAccountIdList &ids)
diff --git a/tests/tst_qmailstore/tst_qmailstore.cpp b/tests/tst_qmailstore/tst_qmailstore.cpp
index 92d22d83..cd4fe210 100644
--- a/tests/tst_qmailstore/tst_qmailstore.cpp
+++ b/tests/tst_qmailstore/tst_qmailstore.cpp
@@ -48,6 +48,9 @@
     This class tests that QMailStore correctly handles addition, updates, removal, counting and
     querying of QMailMessages and QMailFolders.
 */
+
+Q_DECLARE_METATYPE(QMailMessageKey::Properties)
+
 class tst_QMailStore : public QObject
 {
     Q_OBJECT
@@ -78,8 +81,19 @@ private slots:
     void removeMessageWithInResponse();
     void message();
     void implementationbase();
+
+#ifdef USE_ACCOUNTS_QT
+private:
+    static const QSet<QString> defaultMailServices;
+#endif
 };
 
+#ifdef USE_ACCOUNTS_QT
+// Keep in sync with src/libraries/qmfclient/share/email.service
+const QSet<QString> tst_QMailStore::defaultMailServices =
+    QSet<QString>() << "auth" << "crypto";
+#endif
+
 QTEST_MAIN(tst_QMailStore)
 
 #include "tst_qmailstore.moc"
@@ -97,6 +111,7 @@ tst_QMailStore::~tst_QMailStore()
 void tst_QMailStore::initTestCase()
 {
     QMailStore::instance()->clearContent();
+    qRegisterMetaType<QMailMessageKey::Properties>("QMailMessageKeyProperties");
 }
 
 void tst_QMailStore::cleanup()
@@ -110,6 +125,9 @@ void tst_QMailStore::cleanupTestCase()
 
 void tst_QMailStore::addAccount()
 {
+
+    QSignalSpy spyAccountAdded(QMailStore::instance(), SIGNAL(accountsAdded(QMailAccountIdList)));
+
     QMailAccount account1;
     account1.setName("Account 1");
     account1.setFromAddress(QMailAddress("Account 1", "account1@example.org"));
@@ -132,9 +150,9 @@ void tst_QMailStore::addAccount()
         svcCfg->setValue("username", "account1");
     }
 
-    // Verify that invalid retrieval fails
+    // Verify that invalid retrieval succeeds but returns an invalid account
     QMailAccount accountX(account1.id());
-    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::InvalidId);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
     QVERIFY(!accountX.id().isValid());
     
     // Verify that addition is successful
@@ -147,6 +165,9 @@ void tst_QMailStore::addAccount()
     QCOMPARE(QMailStore::instance()->countAccounts(), 1);
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
 
+    // Verify that the addAccount signal is emitted only once
+    QCOMPARE(spyAccountAdded.count(), 1);
+
     // Verify that retrieval yields matching result
     QMailAccount account2(account1.id());
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
@@ -162,12 +183,22 @@ void tst_QMailStore::addAccount()
 
     QMailAccountConfiguration config2(account1.id());
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+
+#ifdef USE_ACCOUNTS_QT
+    QCOMPARE(config2.services().toSet() - defaultMailServices, config1.services().toSet());
+    foreach (const QString &service, config2.services().toSet() - defaultMailServices) {
+        if (QMailAccountConfiguration::ServiceConfiguration *svcCfg = &config2.serviceConfiguration(service)) {
+            QCOMPARE(svcCfg->values(), config1.serviceConfiguration(service).values());
+        } else QFAIL(qPrintable(QString("no config for %1!").arg(service)));
+    }
+#else
     QCOMPARE(config2.services(), config1.services());
     foreach (const QString &service, config2.services()) {
         if (QMailAccountConfiguration::ServiceConfiguration *svcCfg = &config2.serviceConfiguration(service)) {
             QCOMPARE(svcCfg->values(), config1.serviceConfiguration(service).values());
         } else QFAIL(qPrintable(QString("no config for %1!").arg(service)));
     }
+#endif
 
     QCOMPARE(QMailStore::instance()->countAccounts(QMailAccountKey::id(account1.id())), 1);
     QCOMPARE(QMailStore::instance()->countAccounts(QMailAccountKey::id(account1.id(), QMailDataComparator::NotEqual)), 0);
@@ -707,12 +738,21 @@ void tst_QMailStore::updateAccount()
 
     QMailAccountConfiguration config2(account1.id());
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+#ifdef USE_ACCOUNTS_QT
+    QCOMPARE(config2.services().toSet() - defaultMailServices, config1.services().toSet());
+    foreach (const QString &service, config2.services().toSet() - defaultMailServices) {
+        if (QMailAccountConfiguration::ServiceConfiguration *svcCfg = &config2.serviceConfiguration(service)) {
+            QCOMPARE(svcCfg->values(), config1.serviceConfiguration(service).values());
+        } else QFAIL(qPrintable(QString("no config for %1!").arg(service)));
+    }
+#else
     QCOMPARE(config2.services(), config1.services());
     foreach (const QString &service, config2.services()) {
         if (QMailAccountConfiguration::ServiceConfiguration *svcCfg = &config2.serviceConfiguration(service)) {
             QCOMPARE(svcCfg->values(), config1.serviceConfiguration(service).values());
         } else QFAIL(qPrintable(QString("no config for %1!").arg(service)));
     }
+#endif
 }
 
 void tst_QMailStore::updateFolder()
@@ -1222,8 +1262,12 @@ void tst_QMailStore::updateMessage()
 
 void tst_QMailStore::updateMessages()
 {
+    QSignalSpy spyMessagesAdded(QMailStore::instance(), SIGNAL(messagesAdded(QMailMessageIdList)));
     QSignalSpy spyMessagesUpdated(QMailStore::instance(), SIGNAL(messagesUpdated(QMailMessageIdList)));
     QSignalSpy spyMessagesDataUpdated(QMailStore::instance(), SIGNAL(messageDataUpdated(QMailMessageMetaDataList)));
+    QSignalSpy spyMessagePropertyUpdated(QMailStore::instance(), SIGNAL(messagePropertyUpdated(QMailMessageIdList, QMailMessageKeyProperties, QMailMessageMetaData)));
+    QSignalSpy spyMessageStatusUpdated(QMailStore::instance(), SIGNAL(messageStatusUpdated(QMailMessageIdList, quint64, bool)));
+
 
     QMailAccount account;
     account.setName("Account");
@@ -1299,12 +1343,41 @@ void tst_QMailStore::updateMessages()
     }
 
     //Verify that the signals are only emitted once
+    QCOMPARE(spyMessagesAdded.count(), 1);
     QCOMPARE(spyMessagesUpdated.count(), 1);
     QCOMPARE(spyMessagesDataUpdated.count(), 1);
+    // Verify that was not emitted since we didn't modify message metadata directly
+    QCOMPARE(spyMessagePropertyUpdated.count(),0);
+    QCOMPARE(spyMessageStatusUpdated.count(), 0);
+
+    QMailMessageMetaData data;
+    data.setCustomField("answer", "Fido");
+    data.setCustomField("bicycle", "fish");
+
+    QVERIFY(QMailStore::instance()->updateMessagesMetaData(QMailMessageKey(), QMailMessageKey::Custom, data));
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+
+    // Message was update
+    QCOMPARE(spyMessagesUpdated.count(), 2);
+    // Properties were updated
+    QCOMPARE(spyMessagePropertyUpdated.count(),1);
+    // Status was not updated
+    QCOMPARE(spyMessageStatusUpdated.count(), 0);
+
+    QVERIFY(QMailStore::instance()->updateMessagesMetaData(QMailMessageKey(), QMailMessage::Read, false));
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    // Message was update
+    QCOMPARE(spyMessagesUpdated.count(), 3);
+    // Properties were not updated
+    QCOMPARE(spyMessagePropertyUpdated.count(),1);
+    // Status was updated
+    QCOMPARE(spyMessageStatusUpdated.count(), 1);
 }
 
 void tst_QMailStore::removeAccount()
 {
+    QSignalSpy spyAccountRemoved(QMailStore::instance(), SIGNAL(accountsRemoved(QMailAccountIdList)));
+
     QMailAccount account1;
     account1.setName("Account 1");
     account1.setFromAddress(QMailAddress("Account 1", "account1@example.org"));
@@ -1347,12 +1420,21 @@ void tst_QMailStore::removeAccount()
 
     QMailAccountConfiguration config2(account2.id());
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+#ifdef USE_ACCOUNTS_QT
+    QCOMPARE(config2.services().toSet() - defaultMailServices, config1.services().toSet());
+    foreach (const QString &service, config2.services().toSet() - defaultMailServices) {
+        if (QMailAccountConfiguration::ServiceConfiguration *svcCfg = &config2.serviceConfiguration(service)) {
+            QCOMPARE(svcCfg->values(), config1.serviceConfiguration(service).values());
+        } else QFAIL(qPrintable(QString("no config for %1!").arg(service)));
+    }
+#else
     QCOMPARE(config2.services(), config1.services());
     foreach (const QString &service, config2.services()) {
         if (QMailAccountConfiguration::ServiceConfiguration *svcCfg = &config2.serviceConfiguration(service)) {
             QCOMPARE(svcCfg->values(), config1.serviceConfiguration(service).values());
         } else QFAIL(qPrintable(QString("no config for %1!").arg(service)));
     }
+#endif
 
     // Verify that removal is successful 
     QVERIFY(QMailStore::instance()->removeAccount(account1.id()));
@@ -1360,9 +1442,12 @@ void tst_QMailStore::removeAccount()
     QCOMPARE(QMailStore::instance()->countAccounts(), 0);
     QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
 
-    // Verify that retrieval yields invalid result
+    // Verify that the removeAccount signal is emitted only once
+    QCOMPARE(spyAccountRemoved.count(), 1);
+
+    // Verify that retrieval yields no error and an invalid result
     QMailAccount account3(account1.id());
-    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::InvalidId);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
     QVERIFY(!account3.id().isValid());
 
     QMailAccountConfiguration config3(account1.id());
-- 
2.25.1

